//|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||//*************************************************************//Analysis of current-voltage relationships...//*************************************************************//Macro analyzes a single IV using raw sweep records. Plots peak glutamate-activated currents, determines reversal potential, and//define rectification ratio. //Note: Program has algorithm to identify peak currents.//Note: If peak amplitudes are not uniform, alter Window size and retry.//NOTE--only want algorithm for peaks....needs to be rebuild once SSAnalysis completed...//Macro analyzes steady-state IV using raw sweep records. Plots SS glutamate-activated currents, determines reversal potential, and//defines rectification ratio.Macro PeakIVAnalysis (noofsweeps,groupno,seriesno,totalgroupno,startingvolts,voltincrement,startbaseline,endbaseline,apstart,apend)	Variable noofsweeps = Gnoofsweeps		prompt noofsweeps,"Number of current sweeps"	Variable groupno = Ggroupno	prompt groupno, "Initial Group number"	Variable seriesno = Gseriesno	prompt seriesno, "Series number"	Variable totalgroupno = Gtotalgroupno	prompt totalgroupno, "Total Number of Groups"	Variable startingvolts = Gstartingvolts	prompt startingvolts, "Starting voltage (mV)"	Variable voltincrement = Gvoltincrement	prompt voltincrement, "Voltage increment"	Variable startbaseline = Gstartbaseline	prompt startbaseline, "Start of baseline (pre/0.01; post/0.96)"	Variable endbaseline = Gendbaseline	prompt endbaseline, "End of baseline (pre/0.25; post/0.99)"	Variable apstart = Gapstart	prompt apstart, "Start of test application"	Variable apend = Gapend	prompt apend, "End of test application"		Silent 1		Gnoofsweeps = noofsweeps	Ggroupno = groupno	Gseriesno = seriesno	Gtotalgroupno = totalgroupno	Gstartingvolts = startingvolts	Gvoltincrement = voltincrement	Gstartbaseline = startbaseline	Gendbaseline = endbaseline		Gapstart=apstart	Gapend=apend		Variable/G zeropot		String iniwavename,subtwave	Variable activewindow													//Variable for Peak Current determination	Variable maxcurrent,mincurrent,preakcurrentloc,peakcurrent			//Variables for Peak Current determination	Variable ivolt,evolt										//(i)nitial volt & (e)nd volt	Variable sweepno	Variable negvalue,avgposslope,recratio	Variable ampl, leakcurrent70 //added by RK - for leak and current report at -70mV	Variable approval	Variable rateconstant, tau, temp	Variable mincon, minconloc	Variable conductanceplot = 1	String IVwaveY	String ConductanceWave	String fitwave //added by RK - for tau analysis		Variable meancurrent	Variable stdev	variable normcurrent		String WaveNameBase = GWaveNameBase									//Names used for bpc. Defined in 'Amplifier'	String EndNameBase = GEndNameBase	String PiezoNameBase = GPiezoNameBase			//Define voltage range		ivolt=startingvolts											evolt=ivolt+voltincrement*(noofsweeps-1)							do			IVwaveY="IVwaveY" + num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(noofsweeps) $IVwaveY								//wave with IV-current values						sweepno = 1					do			iniwavename =  WaveNameBase + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno) + EndNameBase			subtwave = "subouto" + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno)										Duplicate/O $iniwavename leakycurrentwave 				//*leak substract wave & convert to pAs				leakycurrentwave=leakycurrentwave*10^12			//converts current to pA							//added by RK - gives leak current at -70mV					if (sweepno == 4)				Wavestats/Q/R = (startbaseline,endbaseline) leakycurrentwave					leakcurrent70=V_min				endif									Wavestats/Q/R=(startbaseline,endbaseline) leakycurrentwave		//defines leakcurrent					leakcurrent=V_avg				leakycurrentwave=leakycurrentwave-leakcurrent		//leak subtraction									Duplicate/O leakycurrentwave $subtwave					//working wave for analysis	//*Routine to identify steady-state current amplitude		//				Wavestats/Q/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. //					$IVwaveY[sweepno-1]=V_avg//*Routine to identify peak current amplitude										Duplicate/O leakycurrentwave $subtwave						//working wave for analysis					Wavestats/Q/R=(apstart, apend) $subtwave							//determining peak current. Need to avoid first part of wave.				maxcurrent=V_max				mincurrent=V_min 				meancurrent=V_avg				stdev=V_sdev					if ((abs(maxcurrent))>(abs(mincurrent)))								peakcurrent=maxcurrent				peakcurrentloc=V_maxloc				//if ((abs(maxcurrent))<((abs(meancurrent))+((stdev)*2)))				//print "questionable:" 				//print ((startingvolts)+((sweepno-1)*(voltincrement))				//endif										else				peakcurrent=mincurrent				peakcurrentloc=V_minloc				endif									Wavestats/Q/R=(peakcurrentloc-0.0001,peakcurrentloc+0.0001) $subtwave		//makes average around peakcurrent			$IVwaveY[sweepno-1]=V_avg								//Assigns peak current to wave													if (sweepno == 1)					Display/W=(300,10,700,400) $subtwave						SetAxis bottom 0,0.35				else					Append $subtwave				endif				//added by RK - measure desens rate		//if (sweepno == 4)		//	CurveFit/Q exp $subtwave(peakcurrentloc, peakcurrentloc+0.08)	/ D		//	rateconstant=W_coef[2]		//	temp=1000/rateconstant		//	tau=temp		//	fitwave="fit_"+subtwave		//		ModifyGraph rgb ($fitwave)=(1,1,1)				//endif					sweepno += 1		while (sweepno<(noofsweeps+1))								SetScale/I x ivolt,evolt,""$IVwaveY							//Setting peak currents to cirrect voltage	////fitting polynomial to selected range		Display/W=(710,10,1110,400) $IVwaveY		Modify mode=3,marker=8,rgb=(0,0,0)		Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10		Modify tick=1,zero=1,nticks=10		Label left "Current (pA)"		Label bottom "Volt (mV)"		 		do			voltagerange()				CurveFit/Q poly 4,$IVwaveY(startvolts,endvolts)/D			Make/O/N=1000 displayfit										//creates wave with higher resolution			SetScale/I x startvolts,endvolts,""displayfit;								//changing scaling from time to voltage		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5+K6*x^6		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4			displayfit=K0+K1*x+K2*x^2+K3*x^3			//	displayfit=K0+K1*x+K2*x^2				Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)	////determining rev potential as above but for fitted polynomial		Duplicate/O displayfit displayfitabs		displayfitabs=abs(displayfit)		Wavestats/Q displayfitabs		zeropot = round(100*V_minloc)/100				CorrectRevPot()												//Inout to verify Reversal Potential. Needed only for Ca2+-permeable AMPARs.																		//Can be remarked out for others...			////Determining rectification ratio		Wavestats/Q/R=(-100,-100) $IVwaveY			negvalue=abs(V_avg)		Wavestats/Q/R=(100,100) $IVwaveY			avgposslope=V_avg			RecRatio =  negvalue/avgposslope		//added by RK - report peak current at -70mV		Wavestats/Q/R=(-70,-70) $IVwaveY			ampl=V_avg					Textbox/A=RB/F=0 "wave= "+ WaveNameBase + num2str(groupno) + "_" + num2str(seriesno)		Appendtext "rev pot= "+num2str(zeropot)		Appendtext "negvalue= "+num2str(round(100*negvalue)/100)		Appendtext "posvalue= "+num2str(round(100*avgposslope)/100)		Appendtext "I @-70mv="+num2str(round(100*ampl/100))		Appendtext "leak @ -70mv="+num2str(leakcurrent70) + "pA"		Appendtext "1/tau =" +num2str(tau)+"ms"		Appendtext "Ratio (-100/+100)= "+num2str(round(100*RecRatio)/100)		Appendtext "ext. soln= "+testsolution				groupno += 1	while(groupno < (totalgroupno + 1))//Routine to determine conductance-voltage plots		if (conductanceplot==1)					ConductanceWave = "IVwaveY" + num2str(groupno - 1) + "_" + num2str(seriesno) + "_G"				Duplicate/O $IVwaveY TempWave							//Steps to determine Conductance...				 TempWave = TempWave/(x-zeropot)					normcurrent = 	Tempwave[0]						TempWave = abs(TempWave*100/normcurrent)/100				 	 			Duplicate/O Tempwave $ConductanceWave				WaveStats/Q/R = () $ConductanceWave					mincon = V_min					minconloc = V_minloc			Display/W=(300,450,700,900) $ConductanceWave			ModifyGraph mode=3,marker=8 			SetAxis bottom -100,100 			SetAxis left 0,1 		 	Label bottom "Vm (mV)"			Label left "Norm Conductance"					ModifyGraph zero(bottom)=1			ModifyGraph rgb=(0,0,0)			Make/O/N = 3 W_coef			W_coef[0] = 1			W_coef[1] = -50			W_coef[2] = 10			FuncFit/Q/H="100" Boltzmann W_coef  $ConductanceWave(-100,0) /D			if (W_coef[2]>30) //this will differentiate between inward rec/Ai and non-rec/double-rec/A2R...RK			FuncFit/Q/H="100" Boltzmann W_coef  $ConductanceWave(-100,minconloc) /D			endif()				Textbox/A=RB/X=5/Y=70/F=0				Appendtext "Vb = " + num2str(round(10*W_coef[1])/10)				Appendtext "slope = "+ num2str(round(10*W_coef[2])/10)				Appendtext "minconloc =" + num2str(round(100000*minconloc)/100000)		endif()	edit/W=(710,450,1000,900) $IVwaveY,$ConductanceWave.xyEnd Macro()///////////////////////////////////////////////////////////////////////////////////////////////////Macro analyzes Ramps...developed for ramps with Lurcher mutation. Hence, no contol (leak)//ramp is substracted.Macro RampAnal (extsoln,testsoln,pregroupno,preseriesno,testgroupno,testseriesno,postgroupno,postseriesno)	String extsoln = Gextsoln	prompt extsoln, "Control Solution"	String testsoln = Gtestsoln	prompt testsoln, "Test Solution"	Variable pregroupno = Gpregroupno	prompt pregroupno, "Group no. of Pre appln"	Variable preseriesno = Gtestseriesno	prompt preseriesno, "Exp. no. of Pre appln"	Variable testgroupno = Gtestgroupno	prompt testgroupno, "Group no. of Test appln"	Variable testseriesno = Gtestseriesno	prompt testseriesno, "Exp. no. of Test appln"	Variable postgroupno = Gpostgroupno	prompt postgroupno, "Group no of Post appln"	Variable postseriesno = Gpostseriesno	prompt postseriesno, "Exp. no. of Post appln"		Gextsoln=extsoln	Gtestsoln=testsoln	Gpregroupno=pregroupno	Gpreseriesno=preseriesno	Gtestgroupno=testgroupno	Gtestseriesno=testseriesno	Gpostgroupno=postgroupno	Gpostseriesno=postseriesno		Silent 1	Variable sweepno = 1	Variable count,nooframps,avgzeropot,avgamp100,avgamp60	String fitanalysiswave		nooframps=3		Make/O/N=(nooframps) zeropot	Make/O/N=(nooframps) amp100	Make/O/N=(nooframps) amp60	String PreHekaWave,TestHekaWave,PostHekaWave,PreWave,TestWave,PostWave	  		PreHekaWave = WaveNameBase + num2str(pregroupno) + "_" + num2str(preseriesno) + "_" + num2str(sweepno)	  			SetScale/I x -105,100,""$PreHekaWave	  		PreWave = "PreWave" + num2str(pregroupno) + "_" + num2str(preseriesno)				Duplicate/O $PreHekaWave $PreWave				$PreWave=$PreWave*10^12				  	TestHekaWave = WaveNameBase + num2str(testgroupno) + "_" + num2str(testseriesno) + "_" + num2str(sweepno)		  		SetScale/I x -105,100,""$TestHekaWave		  		TestWave = "TestWave" + num2str(testgroupno) + "_" + num2str(testseriesno)				Duplicate/O $TestHekaWave $TestWave				$TestWave=$TestWave*10^12	  		PostHekaWave = WaveNameBase + num2str(postgroupno) + "_" + num2str(postseriesno) + "_" + num2str(sweepno)	  			SetScale/I x -105,100,""$PostHekaWave									PostWave = "PostWave" + num2str(postgroupno) + "_" + num2str(postseriesno)				Duplicate/O $PostHekaWave $PostWave				$PostWave=$PostWave*10^12	Display $Prewave,$TestWave,$PostWave		ModifyGraph rgb($PreWave)=(0,0,0)		ModifyGraph rgb($PostWave)=(0,0,0)		ModifyGraph standoff(left)=0		ModifyGraph standoff(bottom)=0		ModifyGraph zero(left)=1		ModifyGraph zero(left)=4		ModifyGraph lblMargin(left)=10		ModifyGraph zero(bottom)=1		ModifyGraph zero(bottom)=4		Label left "Current (pA)"		Label bottom "Volt (mV)"	count=0	do		if (count==0)			Duplicate/O $PreWave analysiswave			fitanalysiswave=PreWave + " _fit"		else			if (count ==1)				Duplicate/O $TestWave analysiswave				fitanalysiswave=TestWave + "_fit"			else				Duplicate/O $PostWave analysiswave				fitanalysiswave=PostWave + "_fit"			endif()					endif()		////subroutine to determine Erev		////fitting polynomial to selected range		Duplicate/O analysiswave $fitanalysiswave		CurveFit/Q poly 4,analysiswave (-90,+40)/D=$fitanalysiswave		Duplicate/O $fitanalysiswave displayfit		displayfit=K0+K1*x+K2*x^2+K3*x^3		Duplicate/O displayfit displayfitabs		displayfitabs=abs(displayfit)		Wavestats/Q displayfitabs		zeropot[count]=round(100*V_minloc)/100		////measure amplitude at -100 mV			WaveStats/Q/R=(-100,-99.5) analysiswave		amp100[count]=V_avg	////Measure amplitude at +60 mV		WaveStats/Q/R=(+59.5,+60) analysiswave		amp60[count]=V_avg		count+=1	while (count<=nooframps)	Textbox/A=MT/X=2/Y=2 "testsoln= "+testsoln	Appendtext "test wavename= " + TestHekaWave		avgzeropot=(zeropot[0]+zeropot[2])/2	avgamp100=(amp100[0]+amp100[2])/2	avgamp60=(amp60[0]+amp60[2])/2		Textbox/A=LT/X=2/y=25 "test rpot:"+num2str(zeropot[1])	TextBox/C/N=text1/F=0	Appendtext "pre&post:"+num2str(avgzeropot)	Appendtext "test amp100:"+num2str(amp100[1])	Appendtext "pre&post:"+num2str(avgamp100)	Appendtext "test amp60:"+num2str(amp60[1])	Appendtext "pre&post:"+num2str(avgamp60)End Macro()/////////////////////////////////////////////////////////////Macro analyzes steady-state IV for AMPARs using raw sweep records. Plots SS glutamate-activated currents, determines reversal potential, and//defines rectification ratio.  Does fraction block for polyamine block.//REQUIRES UPDATINGMacro SSIVAnal_AMPA (noofsweeps,groupno,seriesno,totalgroupno,startingvolts,voltincrement,startbaseline,endbaseline,startSScurrent,endSScurrent)	Variable noofsweeps = Gnoofsweeps		prompt noofsweeps,"Number of current sweeps"	Variable groupno = Ggroupno	prompt groupno, "Initial Group number"	Variable seriesno = Gseriesno	prompt seriesno, "Exp. number"	Variable totalgroupno = Gtotalgroupno	prompt totalgroupno, "Total Number of Groups"	Variable startingvolts = Gstartingvolts	prompt startingvolts, "Starting voltage (mV)"	Variable voltincrement = Gvoltincrement	prompt voltincrement, "Voltage increment"	Variable startbaseline = Gstartbaseline	prompt startbaseline, "Start of baseline (pre/0.01; post/0.96)"	Variable endbaseline = Gendbaseline	prompt endbaseline, "End of baseline (pre/0.25; post/0.99)"	Variable startSScurrent = GstartSScurrent	prompt startSScurrent, "Start of SS Current Avg"	Variable endSScurrent = GendSScurrent	prompt endSScurrent, "End of SS Current Avg"//	Silent 1		Gnoofsweeps = noofsweeps	Ggroupno = groupno	Gseriesno = seriesno	Gtotalgroupno = totalgroupno	Gstartingvolts = startingvolts	Gvoltincrement = voltincrement	Gstartbaseline = startbaseline	Gendbaseline = endbaseline	GstartSScurrent = startSScurrent	GendSScurrent = endSScurrent		Variable/G zeropot		String iniwavename,subtwave	String WaveNameBase="pulse"	String EndNameBase= "_1-Imon"	Variable window=30									//defines window to locate peak current--needed??	Variable activewindow	Variable ivolt,evolt										//(i)nitial volt & (e)nd volt	Variable sweepno	Variable maxcurrent,mincurrent,preakcurrentloc,peakcurrent	Variable negvalue,avgposslope,recratio, neg70	Variable approval	Variable normcurrent	Variable conductanceplot = 1			String IVwaveY,SSMarker,IVwaveYinv	String ConductanceWave	String ConductanceWaveinv		//Define voltage range		ivolt=startingvolts											evolt=ivolt+voltincrement*(noofsweeps-1)				do			IVwaveY="IVwaveY" + num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(noofsweeps) $IVwaveY								//wave with IV-current values		IVwaveYinv="IVwaveYinv" + num2str(groupno) + "_" + num2str(seriesno)		Make/O/N=(noofsweeps)$IVwaveYinv		SSMarker="SSMarker" +num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(2) $SSMarker										//wave with Marker to decribe range for SS currents		sweepno = 1					do			iniwavename =  WaveNameBase + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno) + EndNameBase			subtwave = "subouto" + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno)			Duplicate/O $iniwavename leakycurrentwave 				//*leak substract wave & convert to pAs				leakycurrentwave=leakycurrentwave*10^12			//converts current to pA				Wavestats/Q/R=(startbaseline,endbaseline) leakycurrentwave		//defines leakcurrent					leakcurrent=V_avg				leakycurrentwave=leakycurrentwave-leakcurrent		//leak subtraction						Duplicate/O leakycurrentwave $subtwave					//working wave for analysis		//		Wavestats/Q/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 				Wavestats/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 					$IVwaveY[sweepno-1]=V_avg				$IVwaveYinv[noofsweeps-sweepno]=V_avg //to generate inverse IV curve										if (sweepno == 1)					Display/W=(300,10,700,400) $subtwave						$SSMarker[0]=V_avg+-50; $SSMarker[1]=V_avg+-50						SetScale/I x startSScurrent,endSScurrent,""$SSMarker						Append $SSMarker						ModifyGraph rgb($SSMarker)=(0,0,0)						ModifyGraph mode($SSMarker)=4																		//				SetAxis bottom 0,0.1		else		Append $subtwave		endif				sweepno += 1		while (sweepno<(noofsweeps+1))				SetScale/I x ivolt,evolt,""$IVwaveY							//Setting peak currents to cirrect voltage	////fitting polynomial to selected range		Display/W=(710,10,1110,400) $IVwaveY		Modify mode=3,marker=8,rgb=(0,0,0)		Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10		Modify tick=1,zero=1,nticks=10		Label left "Current (pA)"		Label bottom "Volt (mV)"		do			voltagerange()				CurveFit/Q poly 4,$IVwaveY(startvolts,endvolts)/D			Make/O/N=1000 displayfit										//creates wave with higher resolution			SetScale/I x startvolts,endvolts,""displayfit;								//changing scaling from time to voltage		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5+K6*x^6		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4			displayfit=K0+K1*x+K2*x^2+K3*x^3			//	displayfit=K0+K1*x+K2*x^2				Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)	////determining rev potential as above but for fitted polynomial		Duplicate/O displayfit displayfitabs		displayfitabs=abs(displayfit)		Wavestats/Q displayfitabs		zeropot = round(100*V_minloc)/100				CorrectRevPot()												//Inout to verify Reversal Potential. Needed only for Ca2+-permeable AMPARs.																		//Can be remarked out for others...	////Determining rectification ratio		Wavestats/Q/R=(zeropot-40,zeropot-40) $IVwaveY			negvalue=abs(V_avg)		Wavestats/Q/R=(zeropot+40,zeropot+40) $IVwaveY			avgposslope=abs(V_avg)					// Wavestats/Q/R=(-100,-100) $IVwaveY			//negvalue=abs(V_avg)		//Wavestats/Q/R=(100,100) $IVwaveY			//avgposslope=V_avg						RecRatio =  negvalue/avgposslope				Wavestats/Q/R=(-70,-70) $IVwaveY			neg70=(V_avg)					Textbox/A=RB/F=0 "wave= "+WaveNameBase + num2str(groupno) + "_" + num2str(seriesno)		Appendtext "rev pot= "+num2str(zeropot)		Appendtext "negvalue= "+num2str(round(100*negvalue)/100)		Appendtext "posvalue= "+num2str(round(100*avgposslope)/100)		Appendtext "I @-70mV="+num2str(round(100*neg70)/100)		Appendtext "Ratio (-100/+100)= "+num2str(round(100*RecRatio)/100)		Appendtext "ext. soln= "+testsolution		Appendtext "slope=" +num2str(K1)				groupno += 1	while(groupno < (totalgroupno + 1))//Routine to determine conductance-voltage plots		if (conductanceplot==1)					ConductanceWave = "IVwaveY" + num2str(groupno - 1) + "_" + num2str(seriesno) + "_G"	.			Duplicate/O $IVwaveY TempWave							//Steps to determine Conductance...				 TempWave = TempWave/(x - zeropot)					normcurrent = 	Tempwave[0]/100		 				 				 TempWave = abs(TempWave/normcurrent)/100	 			Duplicate/O Tempwave $ConductanceWave					Display/W=(300,450,700,900) $ConductanceWave			ModifyGraph mode=3,marker=8 			SetAxis bottom -100,100 			SetAxis left 0,1 		 	Label bottom "Vm (mV)"			Label left "Norm Conductance"					ModifyGraph zero(bottom)=1			ModifyGraph rgb=(0,0,0)			//Make/O/N = 3 W_coef			//W_coef[0] = 1			//W_coef[1] = -50			//W_coef[2] = 10			//FuncFit/Q/H="100" Boltzmann W_coef  $ConductanceWave(-100,zeropot) /D				//Textbox/A=RB/X=5/Y=70/F=0				//Appendtext "Vb = " + num2str(round(10*W_coef[1])/10)				//Appendtext "slope = "+ num2str(round(10*W_coef[2])/10)						voltagerange()						CurveFit/Q line,$ConductanceWave(startvolts,endvolts)/D			Make/O/N= 1000 displayfit										//creates wave with higher resolution			SetScale/I x startvolts,endvolts,""displayfit;								//changing scaling from time to voltage						Textbox/A=RB/X=5/Y=70/F=0			Appendtext "lin_slope = "+ num2str(K1)						Make/O/N = 3 W_coef			W_coef[0] = 1			W_coef[1] = -50			W_coef[2] = 10			FuncFit/Q/H="100" Boltzmann W_coef  $ConductanceWave(-100, zeropot) /D				Appendtext "Vb = " + num2str(round(10*W_coef[1])/10)				Appendtext "b_slope = "+ num2str(round(10*W_coef[2])/10)		endif()			edit/W=(710,450,1000,900) $IVwaveY,$ConductanceWave.xyEnd Macro()/////////////////////////////////////////////////////////////Macro analyzes steady-state IV for NMDARs using raw sweep records. Plots SS glutamate-activated currents, determines reversal potential, and//defines rectification ratio.  Quantifies Mg2+ block using Boltzmann equation.Macro SSIVAnal_NMDA (noofsweeps,groupno,seriesno,totalgroupno,startingvolts,voltincrement,startSScurrent,endSScurrent,preorpost)	Variable noofsweeps = Gnoofsweeps		prompt noofsweeps,"Number of current sweeps"	Variable groupno = Ggroupno	prompt groupno, "Initial Group number"	Variable seriesno = Gseriesno	prompt seriesno, "Exp. number"	Variable totalgroupno = Gtotalgroupno	prompt totalgroupno, "Total Number of Groups"	Variable startingvolts = Gstartingvolts	prompt startingvolts, "Starting voltage (mV)"	Variable voltincrement = Gvoltincrement	prompt voltincrement, "Voltage increment"	Variable startSScurrent = GstartSScurrent	prompt startSScurrent, "Start of SS Current Avg"	Variable endSScurrent = GendSScurrent	prompt endSScurrent, "End of SS Current Avg"	Variable preorpost = 1	prompt preorpost, "Control pre (= 1) or post (= 2)"	Silent 1		Gnoofsweeps = noofsweeps	Ggroupno = groupno	Gseriesno = seriesno	Gtotalgroupno = totalgroupno	Gstartingvolts = startingvolts	Gvoltincrement = voltincrement	GstartSScurrent = startSScurrent	GendSScurrent = endSScurrent		Variable startbaseline = 0.01,endbaseline = 0.05	Variable/G zeropot		String iniwavename,subtwave	String WaveNameBase="pulse"	String EndNameBase= "_1_I-mon"	String precontrolwave, postcontrolwave, avgwave, blockwave,fractionwave	String testsoln,displaywave		String ratiowave, fitratiowave, displayratiowave	String IVwaveY,SSMarker,IVwaveYinv	Variable ivolt,evolt										//(i)nitial volt & (e)nd volt	Variable firstgroupno = groupno							//need to track first group for setting precontrolwave etc.	Variable sweepno, counter	Variable approval	Variable extcurrent_loc, wndow = 0.01, peakwindow	Variable conductanceplot = 1	Variable charge=2,RT_F=25.4	Variable slope, y_int, delta, K_0, K_0inv	Variable blockerconc = 0.1		//need to create more flexibility...		//Define voltage range		ivolt=startingvolts											evolt=ivolt+voltincrement*(noofsweeps-1)				counter = 1		do								//Main loop - Cycles based on groupnumber//				if (groupno == firstgroupno + 1)						//Series#2 routine.  Need to also change blockwave below.//					seriesno = seriesno + 1//				else//					seriesno = seriesno//				endif			IVwaveY="IVwaveY" + num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(noofsweeps) $IVwaveY								//wave with IV-current values		IVwaveYinv="IVwaveYinv" + num2str(groupno) + "_" + num2str(seriesno)		Make/O/N=(noofsweeps)$IVwaveYinv		SSMarker="SSMarker" +num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(2) $SSMarker										//wave with Marker to decribe range for SS currents		sweepno = 1						do			if (sweepno < 10)										//Needed to allow user to analyze single later traces				iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepno) + EndNamebase			else				if (sweepno < 100)					iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepno) + EndNamebase				else					iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepno) + EndNamebase				endif()			endif()			subtwave = "subouto" + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno)			Duplicate/O $iniwavename leakycurrentwave 				//*leak substract wave & convert to pAs				leakycurrentwave=leakycurrentwave*10^12			//converts current to pA				Wavestats/Q/R=(startbaseline,endbaseline) leakycurrentwave		//defines leakcurrent					leakcurrent=V_avg				leakycurrentwave=leakycurrentwave-leakcurrent		//leak subtraction						Duplicate/O leakycurrentwave $subtwave					//working wave for analysis		//		Wavestats/Q/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 				Wavestats/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 										if (V_avg < 0)									//Algorithm to select either V_min or V_max dependeing on average value							extcurrent_loc = V_minloc							Wavestats/Q/R=(extcurrent_loc-wndow,extcurrent_loc+wndow) $subtwave				//determining peak current for baseline application.							peakcurrent = V_avg						else							extcurrent_loc = V_maxloc							Wavestats/Q/R=(extcurrent_loc-wndow,extcurrent_loc+wndow) $subtwave				//determining peak current for baseline application.							peakcurrent = V_avg						endif					$IVwaveY[sweepno-1]=peakcurrent//				$IVwaveYinv[noofsweeps-sweepno]=V_avg 							//to generate inverse IV curve										if (sweepno == 1)					Display/W=(300,10,700,400) $subtwave						$SSMarker[0]=V_avg+-50; $SSMarker[1]=V_avg+-50						SetScale/I x startSScurrent,endSScurrent,""$SSMarker						Append $SSMarker						ModifyGraph rgb($SSMarker)=(0,0,0)						ModifyGraph mode($SSMarker)=4				else					Append $subtwave				endif					sweepno += 1		while (sweepno<(noofsweeps+1))				SetScale/I x ivolt,evolt,""$IVwaveY							//Setting peak currents to cirrect voltage	////fitting polynomial to selected range		Display/W=(710,10,1110,400) $IVwaveY		Modify mode=3,marker=8,rgb=(0,0,0)		Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10		Modify tick=1,zero=1,nticks=10		Label left "Current (pA)"		Label bottom "Volt (mV)"					do															//Routine to determine if fit is OK.  Allows reinput of fit parameters.			voltagerange()				CurveFit/Q poly 4,$IVwaveY(startvolts,endvolts)/D			Make/O/N=1000 displayfit										//creates wave with higher resolution			SetScale/I x startvolts,endvolts,""displayfit;								//changing scaling from time to voltage		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5+K6*x^6		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4			displayfit=K0+K1*x+K2*x^2+K3*x^3			//	displayfit=K0+K1*x+K2*x^2				Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)	////determining rev potential as above but for fitted polynomial		Duplicate/O displayfit displayfitabs		displayfitabs=abs(displayfit)		Wavestats/Q displayfitabs		zeropot = round(100*V_minloc)/100		//		CorrectRevPot()												//Inout to verify Reversal Potential. Needed only for Ca2+-permeable AMPARs.																		//Can be remarked out for others...		Textbox/A=RB/F=0 "wave= "+WaveNameBase + num2str(groupno) + "_" + num2str(seriesno)		Appendtext "rev pot= "+num2str(zeropot)		Appendtext "ext. soln= "+testsolution					groupno += 1		counter += 1	while(counter < (totalgroupno + 1))//*****routine to plot and fit voltage-dependent block data*****		seriesno = Gseriesno					//Resetting seriesno to accommdate possible Series#2 routine													//Change series number to accommodate Series#2 routine					if (preorpost==1)						//Defines whether single control is pre (= 1) or post (= 2)			precontrolwave = "IVwaveY" + num2str(firstgroupno) + "_" + num2str(seriesno)				if (totalgroupno==3)										postcontrolwave  = "IVwaveY" + num2str(firstgroupno+2) + "_" +num2str(seriesno)				else 					postcontrolwave = "IVwaveY" + num2str(firstgroupno) + "_" + num2str(seriesno)				endif			blockwave="IVwaveY" + num2str(firstgroupno+1)+ "_" + num2str(seriesno)			avgwave = "avgwave" + num2str(firstgroupno)					else			precontrolwave = "IVwaveY" + num2str(firstgroupno+1) + "_" + num2str(seriesno)			postcontrolwave  = "IVwaveY" + num2str(firstgroupno+1) + "_" +num2str(seriesno)			blockwave="IVwaveY" + num2str(firstgroupno)+ "_" + num2str(seriesno)			avgwave = "avgwave" + num2str(firstgroupno+1)		endif		//		blockwave="IVwaveY" + num2str(firstgroupno+1)+ "_" + num2str(seriesno + 1)			//Use for Series#2 routine					ratiowave="ratio"+num2str(firstgroupno)		fitratiowave="fitratio"+num2str(firstgroupno)		displayratiowave="displayfitwave"+num2str(firstgroupno)	//creating waves for manipulation...		Duplicate/O $precontrolwave prewave						Duplicate/O $postcontrolwave postwave		Duplicate/O $precontrolwave avgwavetemp			avgwavetemp=(prewave+postwave)/2		Duplicate/O avgwavetemp $avgwave		Duplicate/O $blockwave bwave		Duplicate/O avgwavetemp rwave		Duplicate/O avgwavetemp fwave//******Routine for DFrancisco vdependent analysis		rwave=ln(bwave/(avgwavetemp-bwave))			display rwave				DoWindow/C RwavePlot			ModifyGraph mode(rwave)=3,marker=8,rgb=(0,0,0)			Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10			Modify tick=1,zero=1,nticks=10			Label left "ln(Ib/(Icon-Ib))"			Label bottom "Volt (mV)"				sweepno = 1		do															//Routine to determine if fit is OK.  Allows reinput of fit parameters.			voltagerange2()			DoWindow/F RwavePlot						CurveFit/Q line rwave(startvolts,endvolts)  /D 				slope=W_coef[1]				y_int=W_coef[0]				delta=slope*RT_F/charge										//RT/F=25.4				K_0=blockerconc*exp(y_int)				Textbox/A=LT/X=2/Y=5 "Blocker conc.="+num2str(blockerconc)			Appendtext "delta= "+num2str(round(100*delta)/100)			Appendtext "K_0= "+num2str(round(100*K_0)/100)			Appendtext "ivolt= "+num2str(startvolts)			Appendtext "evolt= "+num2str(endvolts)				//creating plot with current vs voltage					if (sweepno == 1)				Display/W=(300,10,700,400) $avgwave					DoWindow/C BlockwavePlot				Append $blockwave					ModifyGraph mode($avgwave)=4,marker($avgwave)=8,rgb($avgwave)=(0,0,0)					ModifyGraph mode($blockwave)=3,marker($blockwave)=19,rgb($blockwave)=(0,0,0)					Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10					Modify tick=1,zero=1,nticks=10					Label left "Current (pA)"					Label bottom "Volt (mV)"			endif								DoWindow/F BlockwavePlot			fwave=avgwavetemp/(1 + blockerconc *exp(-(charge*delta*x)/RT_F)*1/K_0)				Append fwave					ModifyGraph mode(fwave)=0,rgb(fwave)=(0,0,0)						sweepno += 1			Agreement()												//Verifies that fit is OK...			Approval = YesOrNo		while(Approval !=1)	//Determines fractional unblock 		fractionwave = "fractionwave" + num2str(firstgroupno)			Duplicate/O $avgwave awave		Duplicate/O $blockwave mwave		Duplicate/O awave wavefraction			wavefraction=(mwave/awave)*100			wavefraction=100-(round(10*wavefraction)/10)		Duplicate/O wavefraction $fractionwave		Display $fractionwave			ModifyGraph mode=3,marker=5,rgb=(0,0,0)			ModifyGraph zero(bottom)=1			Label left "Current UnBlock (%)"			Label bottom "Volt (mV)"			SetAxis left 0,100 					Textbox/A=RB/X=5/Y=70/F=0									Make/O/N = 3 W_coef				W_coef[0] = 100				W_coef[1] = -50				W_coef[2] = 10					do																//Routine to determine if fit is OK.  Allows reinput of fit parameters.			voltagerange()			FuncFit/Q/H="100" Boltzmann W_coef  $fractionwave(startvolts,endvolts) /D			FuncFit/Q Boltzmann W_coef  $fractionwave(startvolts,endvolts) /D				Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)				Appendtext "Max = " + num2str(round(10*W_coef[0])/10)				Appendtext "Vb = " + num2str(round(10*W_coef[1])/10)				Appendtext "b_slope = "+ num2str(round(10*W_coef[2])/10)				Edit $fractionwave.xy,$avgwave,$blockwaveEnd Macro()/////////////////////////////////////////////////////////////Macro analyzes steady-state IV using raw sweep records. Plots SS glutamate-activated currents and determines reversal potential.Macro RevPotential (groupno,seriesno,noofsweeps,avgseries,startingvolts,voltincrement,startbaseline,endbaseline,startSScurrent,endSScurrent)	Variable groupno = Ggroupno	prompt groupno, "Initial Group number"	Variable seriesno = Gseriesno	prompt seriesno, "Series number"	Variable noofsweeps = Gnoofsweeps		prompt noofsweeps,"Number of current sweeps"	Variable avgseries = 1	prompt 	avgseries, "Number of Series to average?"	Variable startingvolts = Gstartingvolts	prompt startingvolts, "Starting voltage (mV)"	Variable voltincrement = Gvoltincrement	prompt voltincrement, "Voltage increment"	Variable startbaseline = Gstartbaseline	prompt startbaseline, "Start of baseline (pre/0.01; post/0.96)"	Variable endbaseline = Gendbaseline	prompt endbaseline, "End of baseline (pre/0.25; post/0.99)"	Variable startSScurrent = GstartSScurrent	prompt startSScurrent, "Start of SS Current Avg"	Variable endSScurrent = GendSScurrent	prompt endSScurrent, "End of SS Current Avg"//	Silent 1		Gnoofsweeps = noofsweeps	Ggroupno = groupno	Gseriesno = seriesno	Gstartingvolts = startingvolts	Gvoltincrement = voltincrement	Gstartbaseline = startbaseline	Gendbaseline = endbaseline	GstartSScurrent = startSScurrent	GendSScurrent = endSScurrent		Variable/G zeropot		String iniwavename,subtwave	String addwavename	String WaveNameBase = GWaveNameBase									//Names used for bpc. Defined in 'Amplifier'	String EndNameBase = GEndNameBase	String PiezoNameBase = GPiezoNameBase	Variable window=30									//defines window to locate peak current--needed??	Variable activewindow	Variable ivolt,evolt										//(i)nitial volt & (e)nd volt	Variable sweepno	Variable maxcurrent,mincurrent,preakcurrentloc,peakcurrent	Variable negvalue,avgposslope,recratio, neg70	Variable approval	Variable normcurrent	Variable conductanceplot = 1	Variable averagecounter			String IVwaveY,SSMarker,IVwaveYinv	String ConductanceWave	String ConductanceWaveinv		//Define voltage range		ivolt=startingvolts											evolt=ivolt+voltincrement*(noofsweeps-1)			//	do			IVwaveY="IVwaveY" + num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(noofsweeps) $IVwaveY								//wave with IV-current values		IVwaveYinv="IVwaveYinv" + num2str(groupno) + "_" + num2str(seriesno)		Make/O/N=(noofsweeps)$IVwaveYinv		SSMarker="SSMarker" +num2str(groupno) + "_" + num2str(seriesno) 		Make/O/N=(2) $SSMarker										//wave with Marker to decribe range for SS currents		sweepno = 1					do						if (sweepno < 10)										//Needed to allow user to analyze single later traces					iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepno) + EndNamebase				else					if (sweepno < 100)						iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepno) + EndNamebase					else						iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepno) + EndNamebase					endif()			endif()			subtwave = "subouto" + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepno)					//for averaging series			averagecounter = 0			Duplicate/O $iniwavename averagecurrentwave 			do						if (sweepno < 10)										//Needed to allow user to analyze single later traces						addwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(seriesno + averagecounter) + "_00" + num2str(sweepno) + EndNamebase					else						if (sweepno < 100)							addwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(seriesno + averagecounter) + "_0" + num2str(sweepno) + EndNamebase						else							addwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(seriesno + averagecounter) + "_" + num2str(sweepno) + EndNamebase						endif()					endif()															Duplicate/O $addwavename addcurrentwave 					averagecurrentwave += addcurrentwave				averagecounter += 1							while (averagecounter < avgseries)							averagecurrentwave = averagecurrentwave/(averagecounter +1)			Duplicate/O averagecurrentwave leakycurrentwave 				//*leak substract wave & convert to pAs				leakycurrentwave=leakycurrentwave*10^12			//converts current to pA				Wavestats/Q/R=(startbaseline,endbaseline) leakycurrentwave		//defines leakcurrent					leakcurrent=V_avg				leakycurrentwave=leakycurrentwave-leakcurrent		//leak subtraction						Duplicate/O leakycurrentwave $subtwave					//working wave for analysis		//		Wavestats/Q/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 				Wavestats/R=(startSScurrent,endSScurrent) $subtwave			//determining SS current. 					$IVwaveY[sweepno-1]=V_avg				$IVwaveYinv[noofsweeps-sweepno]=V_avg //to generate inverse IV curve										if (sweepno == 1)					Display/W=(300,10,700,400) $subtwave						$SSMarker[0]=V_avg+-50; $SSMarker[1]=V_avg+-50						SetScale/I x startSScurrent,endSScurrent,""$SSMarker						Append $SSMarker						ModifyGraph rgb($SSMarker)=(0,0,0)						ModifyGraph mode($SSMarker)=4																		//				SetAxis bottom 0,0.1		else		Append $subtwave		endif				sweepno += 1		while (sweepno<(noofsweeps+1))				SetScale/I x ivolt,evolt,""$IVwaveY							//Setting peak currents to cirrect voltage	////fitting polynomial to selected range		Display/W=(710,10,1110,400) $IVwaveY		Modify mode=3,marker=8,rgb=(0,0,0)		Modify tick(bottom)=1,zero(bottom)=1,nticks(bottom)=10		Modify tick=1,zero=1,nticks=10		Label left "Current (pA)"		Label bottom "Volt (mV)"		do			voltagerange()				CurveFit/Q poly 4,$IVwaveY(startvolts,endvolts)/D			Make/O/N=1000 displayfit										//creates wave with higher resolution			SetScale/I x startvolts,endvolts,""displayfit;								//changing scaling from time to voltage		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5+K6*x^6		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4+K5*x^5		//	displayfit=K0+K1*x+K2*x^2+K3*x^3	+K4*x^4			displayfit=K0+K1*x+K2*x^2+K3*x^3			//	displayfit=K0+K1*x+K2*x^2				Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)	////determining rev potential as above but for fitted polynomial		Duplicate/O displayfit displayfitabs		displayfitabs=abs(displayfit)		Wavestats/Q displayfitabs		zeropot = round(100*V_minloc)/100				CorrectRevPot()												//Inout to verify Reversal Potential. Needed only for Ca2+-permeable AMPARs.																		//Can be remarked out for others...		Textbox/A=RB/F=0 "wave= "+WaveNameBase + num2str(groupno) + "_" + num2str(seriesno)		Appendtext "rev pot= "+num2str(zeropot)		Appendtext "ext. soln= "+testsolution				groupno += 1//	while(groupno < (totalgroupno + 1))End Macro()/////////////////////////////////////////////////////////////////////////////////////////////////	