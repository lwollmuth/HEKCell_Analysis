//***********************************************************************////Analysis of Outside-out patches...////***********************************************************************//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////***Routine to measure delay to first opening.Macro DelaytoFirst(GroupNo,SeriesNo,FirstSweepNo,TotalNoSweeps,CurrentAmplitude,SamplingFrequency,ThresholdCorrect)	Variable GroupNo = GGroupNo		prompt GroupNo, "Group number"	Variable SeriesNo = GSeriesNo		prompt SeriesNo, "Series number"	Variable FirstSweepNo = GFirstSweepNo		prompt FirstSweepNo, "First sweep number"	Variable TotalNoSweeps = GTotalNoSweeps		prompt TotalNoSweeps, "Total number of sweeps"	Variable CurrentAmplitude = GCurrentAmplitude		prompt CurrentAmplitude, "Single channel current amplitude (pAs)? "	Variable SamplingFrequency = 10		prompt SamplingFrequency, "Sampling Frequency (kHz)?"	Variable ThresholdCorrect = -1		prompt ThresholdCorrect, "Threshold correction: N2A, N2B (-1) or N2C, N2D (-0.5)?"		Silent 1	GGroupNo = GroupNo	GSeriesNo = SeriesNo	GFirstSweepNo = FirstSweepNo	GTotalNoSweeps = TotalNoSweeps	GCurrentAmplitude = CurrentAmplitude	Gthresholdcorrect = ThresholdCorrect	Variable/G Gstartleak = 0.01, Gendleak	Variable/G Gmaxtime		Variable/G Gpiezostart	Variable/G Gthresholdcorrect	Variable	thresholdlevel = 1.0							//level of detection for FindLevels.  Used initially for Piezo wave and then for baseline noise	Variable startpoint	Variable sampleinterval = 1/SamplingFrequency	Variable leakcurrent	Variable Approval	Variable sweepcounter = 0	Variable tabledatacounter = 0							//NEW PARAMETER to permit fistsweep >10   ******************************SEARCH TO FIND	Variable countercleaned = 0	Variable startanalysis,endanalysis	Variable noptstodelete	String firstsweepwave,nextsweepwave	String piezowave													//name for wave with piezo pulses	String delaytofirstcleanedwave		Make/O/N=2 amplitudedisplay	Make/O/N=2 minvaluedisplay	Make/O/N=2 startptdisplay	Make/O/N=2 piezostartdisplay 		Make/O/N=(TotalNoSweeps) delaytofirstvalues		delaytofirstvalues = NaN									//want to delete NaN values!!		String WaveNameBase = GWaveNameBase	String EndNameBase = GEndNameBase	String PiezoNameBase = GPiezoNameBase	//		if (Channeltype == 1)										//New addition. tey to correct for differences in amplitudes either for subtypes or mutants//			Gthresholdcorrect = -1//		else//			Gthresholdcorrect = -0.5//		endif			//	String endnamebase = "_1_CurrentIn"		//for RK data	//*******Parameters to use for RK data//	piezostart = 0.5		//**Define names...ITEM CHANGED PIEZO WAVE ****************************************		if (FirstSweepNo < 10)			firstsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + EndNamebase			piezowave =  wavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + piezonamebase		else			if (FirstSweepNo < 100)				firstsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(FirstSweepNo) + EndNamebase				piezowave =  wavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(FirstSweepNo) + piezonamebase			else				firstsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + EndNamebase				piezowave =  wavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + piezonamebase			endif()		endif()			///!!!!! NEEDS TO BE CORRECTED For 1st sweep > 9		delaytofirstcleanedwave = "delayvalues" + "_" + num2str(GroupNo)//**Identify general parameters for analysis			Wavestats/Q $firstsweepwave									//determine maxtime which is used to set limit on looking for first opening											Gmaxtime = V_npnts*sampleinterval	//**Findlevels finds the startpoint of the piezo record.  This startpoint will be used as reference for start of ALL glutamate applications.	FindLevel/EDGE=1 /Q $piezowave, thresholdlevel		Gpiezostart = V_LevelX			Gendleak = Gpiezostart - 0.005								//uses piezostart time to determine leak current//**finding first openings for a set of sweeps	sweepcounter = FirstSweepNo	tabledatacounter = 0									//**************************************	do		//**determining wave to analyze(tempwave)		if (sweepcounter == FirstSweepNo)			Duplicate/O $firstsweepwave tempwave		else			if (sweepcounter < 10)				nextsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepcounter) + EndNamebase			else				if (sweepcounter < 100)					nextsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepcounter) + EndNamebase				else					nextsweepwave = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepcounter) + EndNamebase				endif()			endif()			Duplicate/O $nextsweepwave tempwave					endif//**Global analysis and view of tempwaveAnalyze tempwave & create items to be displayed		tempwave = tempwave*10^12									//scale to pAmps			Display/W=(10,100,600,500) tempwave					//this displays wave for global picture of recording				Wavestats/Q/R=(Gstartleak,Gendleak) tempwave				//defines leakcurrent			leakcurrent=V_avg		tempwave = tempwave - leakcurrent						//leak subtraction			amplitudedisplay = CurrentAmplitude			SetScale/I x 0,Gmaxtime,"", amplitudedisplay		//**define parameters for piezo start			piezostartdisplay[0] = -5					piezostartdisplay[1] = 2				SetScale/I x Gpiezostart,Gpiezostart+0.00001,"", piezostartdisplay		Wavestats/Q/R=(GstartLeak,GendLeak) tempwave				//need to determine noise of baseline.			thresholdlevel = V_min									//used as first estimate of noise								if (thresholdlevel < -2)							//this was added due to one instance of basekline noise being very high.					thresholdlevel = -2				endif					minvaluedisplay = thresholdlevel			Setscale/I x 0,Gmaxtime,"",minvaluedisplay//**used to define start of first opening & to verify OK.		startanalysis = Gpiezostart		endanalysis = Gmaxtime//**local do...while to determine delay time and if it is reasonable	**				do																			FindLevel/B=1/EDGE=2 /Q/R=(startanalysis,endanalysis) tempwave thresholdlevel + Gthresholdcorrect		//define start of first deflection 				startpoint = V_LevelX				startptdisplay[0] = -5								//defining parameters for displaying startpoint of first event				startptdisplay[1] = 2					SetScale/I x startpoint,startpoint+0.00001,"", startptdisplay	//**displaying tempwave and all associated waves				Display/W=(600,100,1300,500) tempwave					//this display wave and focuses on ROI					SetAxis left (CurrentAmplitude-2),2.5					SetAxis bottom Gpiezostart - 0.01,startpoint + 0.05		//rescale axis to see more clearly the area of interest							if (sweepcounter == FirstSweepNo)					//labeling graphs with wave name - helps to find next wave					Textbox /F=0/A=MT firstsweepwave				else					Textbox /F=0/A=MT nextsweepwave				endif//**display start of identified first opening					Append amplitudedisplay					ModifyGraph lstyle(amplitudedisplay)=3,rgb(amplitudedisplay)=(0,0,0)									Append minvaluedisplay					ModifyGraph lsize(minvaluedisplay)=1,rgb(minvaluedisplay)=(0,0,0),lstyle(minvaluedisplay)=3				Append piezostartdisplay					ModifyGraph lsize(piezostartdisplay)=1.5,rgb(piezostartdisplay)=(0,0,0),lstyle(piezostartdisplay)=3				Append startptdisplay					ModifyGraph lsize(startptdisplay)=1.5,rgb(startptdisplay)=(0,65535,0),lstyle(startptdisplay)=3				Textbox /F=0/A=MB "delay (msec): " + num2str(round((startpoint - Gpiezostart)*10000)/10000)	//display actual delay value - to verify analysis.					AppendText "time (sec): " + num2str(startpoint)//**Subroutine to determine quality of fit				FReAnalyzeorNot()											//verify that outcome is OK or not...					Approval = GReAnalorNot							//"Good enough (y=1); Reanalyze sweep (2); Failures (3); DO NOT ANALYZE (4):"						if (Approval == 1)																								delaytofirstvalues[tabledatacounter] = round((startpoint - Gpiezostart)*10000)/10000		//extra digits for extra sig. digit//********													else							if (Approval == 2)							//Reanalyze																		thresholdlevel = thresholdlevel - 0.5								InputPoints()							//select new range to analyze									startanalysis = Gstartpt									endanalysis = Gendpt																	KillWindow Graph1															else											//Approval is '3' or '4'.								if (Approval == 3)						//means Approval is '3'.  'Failure' 																		delaytofirstvalues[tabledatacounter] = -1		//-1 means 'Failure'. Will become 'NaN' in final table. 									Approval = 1																		else 										//means Approval '4'.  Do not analyze wave. 																	delaytofirstvalues[tabledatacounter] = -2		//-2 means that value will not analyzed and will be removed from final table									Approval = 1																	endif														endif					  						endif								while(Approval !=1)  			sweepcounter+=1  			tabledatacounter+=1			KillWindow Graph1			KillWindow Graph2			while (sweepcounter < TotalNoSweeps+FirstSweepNo)//**need to relabel/remove from delaytofirstvalues those values that are -1 (failure) or -2 (DNA).		sweepcounter = FirstSweepNo									//counter for original data	tabledatacounter = 0	countercleaned = 0												//counter for 'cleaned' data - removal of NaNs		Duplicate/O delaytofirstvalues $delaytofirstcleanedwave	do		if (delaytofirstvalues[tabledatacounter] > 0 )			//Value is not '-1' (Failure) or '-2' (DNA)					$delaytofirstcleanedwave[countercleaned] = round(delaytofirstvalues[tabledatacounter]*100000)/100		//insert number into cleaned wave; change to msecs			countercleaned +=1								else			if (delaytofirstvalues[tabledatacounter] == -1 )	//Failure								$delaytofirstcleanedwave[tabledatacounter] = NaN 				countercleaned +=1												else			//				Print 'slot deleted'				endif						endif				sweepcounter +=1		tabledatacounter+=1		while (sweepcounter < TotalNoSweeps+FirstSweepNo)			noptstodelete = TotalNoSweeps - countercleaned + 2			DeletePoints countercleaned,noptstodelete, $delaytofirstcleanedwave		edit $delaytofirstcleanedwaveEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////***Routine to measure cluster duration for outside-out patches.		//Note. Stored values are actual values minus PiezoStart.		Function ClusterDuration() 	NVAR GGroupno = root:GGroupno	NVAR GSeriesno = root:GSeriesno	NVAR GFirstSweepNo = root:GFirstSweepNo	NVAR GTotalNoSweeps = root:GTotalNoSweeps	NVAR GCurrentAmplitude = root:GCurrentAmplitude	Variable GroupNo = GGroupNo	Variable SeriesNo = GSeriesNo	Variable FirstSweepNo = GFirstSweepNo	Variable TotalNoSweeps = GTotalNoSweeps	Variable CurrentAmplitude = GCurrentAmplitude		Prompt GroupNo, "Group number"	Prompt SeriesNo, "Series number"		Prompt FirstSweepNo, "First sweep number"	Prompt TotalNoSweeps, "Total number of sweeps"	Prompt CurrentAmplitude, "Single channel current amplitude (pAs)? "		DoPrompt "Note this routine assumes that 'Delay to 1st' has been analyzed",GroupNo,SeriesNo,FirstSweepNo,TotalNoSweeps,CurrentAmplitude		if (V_Flag)			return -1													// User canceled		Endif	Silent 1	GGroupNo = GroupNo												//General routine to re-define Global variable	GSeriesNo = SeriesNo	GFirstSweepNo = FirstSweepNo	GTotalNoSweeps = TotalNoSweeps	GCurrentAmplitude = CurrentAmplitude//Global paramaters defined throughout program.	SVAR GWaveNameBase = root:GWaveNameBase						SVAR GEndNameBase = root:GEndNameBase	SVAR GPiezoNameBase = root:GPiezoNameBase//Global variables/waves defined in 'Delay-to-1st'	NVAR Gmaxtime = root:Gmaxtime	NVAR Gstartleak = root:Gstartleak	NVAR Gendleak = root:Gendleak	NVAR Gpiezostart = root:Gpiezostart	NVAR Gthresholdcorrect = root:Gthresholdcorrect	NVAR GReAnalorNot = root:GReAnalorNot	NVAR Gstartpt = root:Gstartpt	NVAR Gendpt = root:Gendpt		Wave delaytofirstvalues	Wave amplitudedisplay	Wave startptdisplay	Wave piezostartdisplay//Active variables	Variable sweepcounter = 0	Variable leakcurrent	Variable thresholdlevel = 1	Variable Approval	Variable startpoint	Variable delaytofirstopening		Variable localcounter											//variables for identifying end of cluster	Variable startanalysis,endanalysis,analysiswindow	Variable preendclusterstart,preendclusterend	Variable endclusterstart,endclusterend	Variable clusterendvalue		Variable thresholdcorrect		Variable closedtime = 0,bindingtime = 0	String firstsweepwave,nextsweepwave	String piezowave													//name for wave with piezo pulses	String delaytofirstcleanedwave		Make/O/N=2 clusterenddisplay 	Make/O/N=(TotalNoSweeps) clusterendvalues//		clusterendvalues = NaN										//want to delete NaN values!!	//**Define names of 1st sweep		if (FirstSweepNo < 10)			firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + GEndNamebase		else			if (FirstSweepNo < 100)				firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(FirstSweepNo) + GEndNamebase			else				firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + GEndNamebase			endif		endif		piezowave =  Gwavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + Gpiezonamebase//		delaytofirstcleanedwave = "delayvalues" + "_" + num2str(GroupNo)//**finding first openings for a set of sweeps	sweepcounter = FirstSweepNo	do																		//Main loop - Use sweepcounter to advance//**determining wave to analyze(tempwave)		if (delaytofirstvalues[sweepcounter-1] < 0	)				//Do not analyze sweep with no event			clusterendvalues[sweepcounter - 1] = NaN			sweepcounter += 1					else			if (sweepcounter == FirstSweepNo)						//Defining name of wave to be analyzed				Duplicate/O $firstsweepwave tempwave			else				if (sweepcounter < 10)					nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepcounter) + GEndNamebase				else					if (sweepcounter < 100)						nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepcounter) + GEndNamebase					else						nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepcounter) + GEndNamebase					endif				endif				Duplicate/O $nextsweepwave tempwave						endif//**General analysis of tempwave		tempwave = tempwave*10^12									//scale to pAmps		Wavestats/Q/R=(Gstartleak,Gendleak) tempwave			//defines leakcurrent			leakcurrent=V_avg		tempwave = tempwave - leakcurrent						//leak subtraction			amplitudedisplay = CurrentAmplitude			SetScale/I x 0,Gmaxtime,"", amplitudedisplay		Wavestats/Q/R=(GstartLeak,GendLeak) tempwave			//need to determine noise of baseline.			thresholdlevel = V_min									//used as first estimate of noise								if (thresholdlevel < -2)							//this was added due to one instance of baseline noise being very high.					thresholdlevel = -2				endif			//**Extract values from DelaytoFirst analysis.		delaytofirstopening = delaytofirstvalues[sweepcounter - 1]			//retrieves delaytofirstvalue...needs to subtract '1' since Igor uses '0'				startpoint = delaytofirstopening + Gpiezostart			SetScale/I x startpoint,startpoint+0.00001,"", startptdisplay	//**Focal view of delay to 1st opening		Display/N='firstopening'/W=(600,100,1300,300) tempwave					//this display wave and focuses on ROI for delta to first.			SetAxis left (CurrentAmplitude-2),2.5			SetAxis bottom Gpiezostart - 0.01,startpoint + 0.05		//rescale axis to see more clearly the area of interest						if (sweepcounter == FirstSweepNo)					//labeling graphs with wave name - helps to find next wave				Textbox /F=0/A=MT firstsweepwave			else				Textbox /F=0/A=MT nextsweepwave			endif//**display identified 1st OPENING					AppendtoGraph amplitudedisplay					ModifyGraph lstyle(amplitudedisplay)=3,rgb(amplitudedisplay)=(0,0,0)									AppendtoGraph piezostartdisplay					ModifyGraph lsize(piezostartdisplay)=1.5,rgb(piezostartdisplay)=(0,0,0),lstyle(piezostartdisplay)=3				AppendtoGraph startptdisplay					ModifyGraph lsize(startptdisplay)=1.5,rgb(startptdisplay)=(0,65535,0),lstyle(startptdisplay)=3						Textbox /F=0/A=MB "delay (msec): " + num2str(round((startpoint - Gpiezostart)*1000000)/1000)	//display actual delay value - to verify analysis.						AppendText "time (sec): " + num2str(startpoint)//**NAJOR VIEW of tempwave...start of analysis to determine CLUSTER DURATION		Display/N='majorview'/W=(10,320,1300,600) tempwave							//this displays wave for GLOBAL picture of recording					Duplicate/O tempwave amplitudewave				amplitudewave = CurrentAmplitude			AppendtoGraph amplitudewave				ModifyGraph lstyle(amplitudewave)=3,rgb(amplitudewave)=(0,0,0)			Wavestats/Q/R=(GstartLeak,GendLeak) tempwave				//need to determine noise of baseline.				thresholdlevel = V_min										//used as first estimate of noise			Duplicate/O tempwave peakleakwave				peakleakwave = thresholdlevel			AppendtoGraph peakleakwave				ModifyGraph lstyle(peakleakwave)=3,rgb(peakleakwave)=(0,0,0),lstyle(peakleakwave)=3//**local do...while to determine cluster duration and if it is reasonable	**	//				localcounter = 1				analysiswindow = 0.05					//variable needs to be more flexible				startanalysis = delaytofirstopening + Gpiezostart				endanalysis = startanalysis + analysiswindow				closedtime = 0				bindingtime = 0.1											//What is this variable???				do							Wavestats/Q/R=(startanalysis,endanalysis) tempwave			//need to determine noise of baseline.								if (V_min < Currentamplitude)									//Channel is still open							preendclusterstart = startanalysis							preendclusterend = endanalysis												else																//Channel is closed. 							endclusterstart = startanalysis							endclusterend = endanalysis														closedtime = closedtime + analysiswindow												endif						//					localcounter =+ 1					startanalysis = endanalysis					endanalysis = startanalysis + analysiswindow					while (closedtime < bindingtime)						//				while (endanalysis < Gmaxtime)//**MINOR VIEW of tempwave...						Display/N=minorview/W=(10,100,600,300)  tempwave				SetAxis bottom preendclusterstart,preendclusterend + analysiswindow										FindLevel/B=2/EDGE=1 /Q/R=(preendclusterstart,preendclusterend + analysiswindow) tempwave (Currentamplitude - thresholdlevel - Gthresholdcorrect) 				clusterendvalue = V_LevelX				//**define parameters for culsterenddisplay				clusterenddisplay[0] = Currentamplitude - 1							clusterenddisplay[1] = 2								SetScale/I x clusterendvalue,clusterendvalue+0.00001,"", clusterenddisplay			AppendtoGraph clusterenddisplay										//Appends 1st estimate of cluster ending to focal view				ModifyGraph lsize(clusterenddisplay)=1.5,rgb(clusterenddisplay)=(0,0,0),lstyle(clusterenddisplay)=3							DoWindow/F majorview													//Calls Major view graph				AppendtoGraph clusterenddisplay					ModifyGraph lsize(clusterenddisplay)=1.5,rgb(clusterenddisplay)=(0,0,0),lstyle(clusterenddisplay)=3					Textbox /F=0/A=MB "cluster end pt (sec): " + num2str(round((clusterendvalue)*1000)/1000)						AppendText "cluster duration (sec): " + num2str(round((clusterendvalue - startpoint)*10000)/10000)			DoUpdate						//**Subroutine to determine quality of fit//**Note. Storing the clusterendvalue - piezo start.  				Do									FReAnalyzeorNot()											//verify that outcome is OK or not...						Approval = GReAnalorNot							//"Good enough (y=1); Reanalyze sweep (2); Failures (3); DO NOT ANALYZE (4):"							if (Approval == 1)																		clusterendvalues[sweepcounter-1] = round((clusterendvalue - Gpiezostart)*10000)/10000		//extra digits for extra sig. digit														else								if (Approval == 2)								//									thresholdlevel = thresholdlevel - 0.5	  									  								FInputValues()							//select new range to analyze										preendclusterstart = Gstartpt										preendclusterend = Gendpt																		FindLevel/B=2/EDGE=1 /Q/R=(preendclusterstart,preendclusterend + analysiswindow) tempwave (Currentamplitude - thresholdlevel - Gthresholdcorrect) 										clusterendvalue = V_LevelX									DoWindow/F minorview										RemoveFromGraph clusterenddisplay																			//**reset cluster display										SetScale/I x clusterendvalue,clusterendvalue+0.00001,"", clusterenddisplay										AppendtoGraph clusterenddisplay										//Appends 1st estimate of cluster ending to focal view											ModifyGraph lsize(clusterenddisplay)=1.5,rgb(clusterenddisplay)=(0,65535,0),lstyle(clusterenddisplay)=3										DoUpdate																			DoWindow/F majorview											RemoveFromGraph clusterenddisplay										AppendtoGraph clusterenddisplay											ModifyGraph lsize(clusterenddisplay)=1.5,rgb(clusterenddisplay)=(0,0,0),lstyle(clusterenddisplay)=3									Textbox /F=0/A=MB "cluster end pt (sec): " + num2str(round((clusterendvalue)*1000)/1000)										AppendText "cluster duration (sec): " + num2str(round((clusterendvalue - startpoint)*10000)/10000)										DoUpdate													else											//Approval is '3' or '4'.																	clusterendvalues[sweepcounter-1] = NaN		//									Approval = 1																	endif					  							endif									while(Approval != 1)		  			sweepcounter += 1		  								KillWindow firstopening					KillWindow majorview						KillWindow minorview			Endif																//Goes with determinitation of value for delaytofirst opening		while (sweepcounter < TotalNoSweeps + 1)		Edit delaytofirstvalues,clusterendvaluesEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////***Routine to measure the macroscopic current - summs individual outside-out sweeps and determines ds.Function SummedDs() 	NVAR GGroupno = root:GGroupno	NVAR GSeriesno = root:GSeriesno	NVAR GFirstSweepNo = root:GFirstSweepNo	NVAR GTotalNoSweeps = root:GTotalNoSweeps	NVAR GCurrentAmplitude = root:GCurrentAmplitude	Variable GroupNo = GGroupNo	Variable SeriesNo = GSeriesNo	Variable FirstSweepNo = GFirstSweepNo	Variable TotalNoSweeps = GTotalNoSweeps	Prompt GroupNo, "Group number"	Prompt SeriesNo, "Series number"		Prompt FirstSweepNo, "First sweep number"	Prompt TotalNoSweeps, "Total number of sweeps"		DoPrompt "Summing outside-out currents for analysis.",GroupNo,SeriesNo,FirstSweepNo,TotalNoSweeps		if (V_Flag)			return -1													// User canceled		Endif	Silent 1	GGroupNo = GroupNo												//General routine to re-define Global variable	GSeriesNo = SeriesNo	GFirstSweepNo = FirstSweepNo	GTotalNoSweeps = TotalNoSweeps		Wave W_coef	Wave delaytofirstvalues//Global paramaters defined throughout program.	SVAR GWaveNameBase = root:GWaveNameBase						SVAR GEndNameBase = root:GEndNameBase	SVAR GPiezoNameBase = root:GPiezoNameBase	//Global variables/waves defined in 'Delay-to-1st'	NVAR Gmaxtime = root:Gmaxtime	NVAR Gstartleak = root:Gstartleak	NVAR Gendleak = root:Gendleak	NVAR GIncludeorNot = root:GIncludeorNot//Active variables	Variable sweepcounter = 0, sweepno	Variable leakcurrent	Variable peakcurrent,peakcurrentloc	Variable piezostart = 0.5,piezoend = 1.5	Variable offsetminus = 0.005, offsetplus = 0.05	String firstsweepwave	Variable sscurrent, PDesens	Variable tau1,tau2,area1,area2,fractionarea1,fractionarea2				//Variable for double exponential fit	Variable weightedtau	String fit																		//String for double exponential fit	Variable Approval													//Variables for Approval			String nextsweepwave	String summedwave												//name for wave with piezo pulses	//**Define names of 1st sweep		if (FirstSweepNo < 10)			firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + GEndNamebase		else			if (FirstSweepNo < 100)				firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(FirstSweepNo) + GEndNamebase			else				firstsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + GEndNamebase			endif		endif//**Summing sweeps		summedwave =  "SummedWave_" + num2str(GroupNo)+ "_" + num2str(SeriesNo)		//defining name for summed currents		duplicate/O $firstsweepwave $summedwave		Wave w = $summedwave			w = 0	sweepcounter = FirstSweepNo	do		if (sweepcounter == FirstSweepNo)						//Defining name of wave to be analyzed				Duplicate/O $firstsweepwave tempwave			else				if (sweepcounter < 10)					nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepcounter) + GEndNamebase				else					if (sweepcounter < 100)						nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepcounter) + GEndNamebase					else						nextsweepwave = GWaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepcounter) + GEndNamebase					endif				endif				Duplicate/O $nextsweepwave tempwave					endif	//**General analysis of tempwave			tempwave = tempwave*10^12									//scale to pAmps			Wavestats/Q/R=(Gstartleak,Gendleak) tempwave			//defines leakcurrent				leakcurrent=V_avg			tempwave = tempwave - leakcurrent						//leak subtraction			Display/W=(500,100,1000,500) tempwave				SetAxis left -10,5							if (sweepcounter == FirstSweepNo)					//labeling graphs with wave name - helps to find next wave					Textbox /F=0/A=MT firstsweepwave				else					Textbox /F=0/A=MT nextsweepwave				endif						DoUpdate		FIncludeorNot()													//Decide whether to include sweep into sum					Approval = GIncludeorNot				if (Approval == 1)						//Include sweep (= 1) or NOT (= 2)				w+=tempwave													//Adding of wave.				  		sweepcounter += 1			  		Else	  			  	  		sweepcounter += 1					Endif						KillWindow Graph1	while (sweepcounter < TotalNoSweeps + 1)	Display/W=(10,100,600,500) $summedwave		ModifyGraph rgb($summedwave)=(0,0,0)//**Findlevels finds the startpoint and endpoint of the PIEZO record.  These points will be used as reference for glutamate applications.//	FindLevel/EDGE=1 /Q $piezowave, thresholdlevel			//Identify start of piezo step//		piezostart = V_LevelX		//		endleak = piezostart - 0.05								//uses piezostart time to determine leak current//	FindLevel/EDGE=2 /Q/R=(piezostart+0.01,) $piezowave, thresholdlevel		//Identify end of piezo step//		piezoend = V_LevelX	//**Define properties of CURRENT wave//	Duplicate/O $summedwave analysiswave						//assigns new name to protect orginal		Wavestats/Q/R=(piezostart,piezostart + 0.10) $summedwave			//determining location of peak current			peakcurrentloc = V_minloc		Wavestats/Q/R=(peakcurrentloc-offsetminus,peakcurrentloc+offsetplus) $summedwave			peakcurrent = round(V_avg*10)/10										//averages inward currents around min current loc 		Wavestats/Q/R=(piezoend - 0.1,piezoend - 0.01) $summedwave			sscurrent = round(V_avg*10)/10										//averages inward currents around min current loc			PDesens = round(((1 - sscurrent/peakcurrent) * 100)*10)/10				CurveFit/Q dblexp_XOffset $summedwave(peakcurrentloc, piezoend-0.01) /D 		//Fit for double exponential fit			tau1 = round((W_coef[2]*1000)*10)/10			tau2 = round((W_coef[4]*1000)*10)/10			area1 =  W_coef[1]			area2 = W_coef[3]			fractionArea1 = round((Area1/(Area1+Area2))*100)/100			fractionArea2 = round((Area2/(Area1+Area2))*100)/100			weightedtau = tau1*fractionarea1 + tau2*fractionarea2				Textbox/F=0/A=RB analysiswave 					Appendtext "current wave: " + firstsweepwave					Appendtext "peak current = " + num2str(peakcurrent) + " pA"					AppendText "SS current = " + num2str(sscurrent) + " pA"					AppendText "% Desensitiation = " + num2str(PDesens) + "%"					AppendText   "weighted tau = " + num2str(weightedtau) + " ms"					AppendText "Tau1 = " + num2str(tau1) + " ms"					AppendText "FArea1 = " + num2str(FractionArea1) 					AppendText "Tau2 = " + num2str(tau2) + " ms"					AppendText "FArea2 = " + num2str(FractionArea2) End//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Function FReAnalyzeorNot()	Variable ReAnalorNot = 1	Prompt ReAnalorNot, "Good enough (y=1); Reanalyze sweep (2); FAILURES (3); DO NOT ANALYZE (4): "		DoPrompt "Quality of fit?", ReAnalorNot				Variable/G GReAnalorNot		GReAnalorNot = ReAnalorNotend///////////////////////////////////////////Function FIncludeorNot()	Variable IncludeorNot = 1	Prompt IncludeorNot, "Include sweep (y=1); Do NOT include sweep (2) "		DoPrompt "Include sweep in average?", IncludeorNot		if (V_Flag)			return -1													// User canceled		Endif				Variable/G GIncludeorNot		GIncludeorNot = IncludeorNotend/////////////////////////////////////////////***Input for start and end points for any function (GGM Smooth & Anlyze)Function FInputValues()	Variable startpoint = 1,endpoint = 10	Prompt startpoint, "Start point"	Prompt endpoint, "End point"		DoPrompt "New start and end points fo rcluster end", startpoint,endpoint		if (V_Flag)			return -1													// User canceled		Endif			Variable/G Gstartpt	Gstartpt = startpoint	Variable/G Gendpt	Gendpt = endpoint		DoUpdateend