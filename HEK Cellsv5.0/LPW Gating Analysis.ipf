//***********************************************************************////Analysis of Basic Gating Properties...////***********************************************************************//***Routine measures current during a single glutamate application.Macro PulseAnal(Type,DataType,GroupNo,SeriesNo, FirstSweepNo,TotalNoSweeps,startss,endss,fittype,fitoffset)	Variable type = Gtype		prompt Type, "AMPA (0), NMDA (1), or AMPA CTZ (2)"	Variable DataType = GDataType		prompt DataType, "Des (0) or Deact (1)"	Variable GroupNo = GGroupNo		prompt GroupNo, "Group number"	Variable SeriesNo = GSeriesNo		prompt SeriesNo, "Series number"	Variable FirstSweepNo = GFirstSweepNo		prompt FirstSweepNo, "First sweep number"	Variable TotalNoSweeps = GTotalNoSweeps		prompt TotalNoSweeps, "Total number of sweeps"	Variable startss = Gstartss		prompt startss, "Start of SS (0.15,AMPA; 2.8, NMDA)"	Variable endss = Gendss		prompt endss, "End of SS (0.2, AMPA; 3.0, NMDA)"	Variable fittype = Gfittype		prompt fittype, "Exp. fit type (1, exp; 2, dbexp)?"	Variable fitoffset = Gfitoffset		prompt fitoffset, "Offset for Fit?" 		Silent 1	Gtype = type	Gstartss = startss	Gendss = endss	GGroupNo = GroupNo	GSeriesNo = SeriesNo	GFirstSweepNo = FirstSweepNo	GTotalNoSweeps = TotalNoSweeps	Gfittype = fittype	Gfitoffset = fitoffset	Make/O/N=(TotalNoSweeps) TestAppln_Loc						//Time values of recovery	Make/O/N=(TotalNoSweeps) TestAppln_Ampl					//Recovery current values	Make/O/N=(TotalNoSweeps) Peak_Loc		Make/O/N=(TotalNoSweeps) Peak_Amp							//Peak currents for base appln 	Make/O/N=(TotalNoSweeps) Peak_SS								//Steady-state currents for base appln 	Make/O/N=(TotalNoSweeps) PRecovery	Make/O/N=(TotalNoSweeps) PRecovery_Norm		Make/O/N=(2) sscurrentampl	String sscurrent		Variable sweepcounter = FirstSweepNo, tau1, tau2, PDesens, Peak_SS, Area1, Area2, FractionArea1, FractionArea2	Variable chargeintegral	Variable startleak = 0.01										//parameters to define baseline for leak substraction	Variable endleak = 0.04	Variable peakcurrentlocbegin,peakcurrentlocend			//parameters for defining average of mean	Variable offsetminus, offsetplus	String firstsweep, avgsweep, nextsweep, fit, act			String WaveNameBase = GWaveNameBase	String EndNameBase = GEndNameBase	String PiezoNameBase = GPiezoNameBase	//	Make/O/N=(TotalNoSweeps) $avgsweep//**Routine to average sweeps**//Average sweeps - bpc-HEKARead version		if (FirstSweepNo < 10)										//Needed to allow user to analyze single later traces			firstsweep =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + EndNamebase		else			if (FirstSweepNo < 100)				firstsweep =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(FirstSweepNo) + EndNamebase			else				firstsweep =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + EndNamebase			endif()		endif()				avgsweep =  WaveNamebase + "_" + num2str(GroupNo)+ "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		sscurrent = "sscurrent_" + num2str(GroupNo)		duplicate/O $firstsweep $avgsweep		$avgsweep = 0		do			if (sweepcounter < 10)				nextsweep = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepcounter) + EndNamebase			else				if (sweepcounter < 100)					nextsweep = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepcounter) + EndNamebase				else					nextsweep = WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepcounter) + EndNamebase				endif()			endif()			$avgsweep+=$nextsweep			sweepcounter+=1				while (sweepcounter < TotalNoSweeps+1)	$avgsweep=$avgsweep/TotalNoSweeps//average sweeps - PPT version//	firstsweep =  WaveNameBase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo) + EndNameBase//	avgsweep =  WaveNameBase + "_" + num2str(GroupNo)+ "_" + num2str(SeriesNo) + "_" + num2str(FirstSweepNo)//	sscurrent = "sscurrent_" + num2str(GroupNo)				///new for NMDARs..for display???//		duplicate/O $firstsweep $avgsweep//		$avgsweep = 0		//		do													//averaging sweeps//			nextsweep = WaveNameBase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepcounter) + EndNameBase//			$avgsweep+=$nextsweep//			sweepcounter+=1		//		while (sweepcounter < TotalNoSweeps+1)		//	$avgsweep=$avgsweep/TotalNoSweeps						$avgsweep=$avgsweep*10^12							//converts current to pA		Wavestats/Q/R=(startleak,endleak) $avgsweep			//defines leakcurrent			leakcurrent = V_avg			$avgsweep=$avgsweep-leakcurrent			//defining parameters for AMPAR versus NMDARs		if (type == 0)											//set parameters for AMPAR (==0)			peakcurrentlocbegin = 0.04 			peakcurrentlocend = 0.105			offsetminus = 0.0005			offsetplus = 0.0002					else																if (type == 1) 									//set parameters for NMDAR (==1)				peakcurrentlocbegin = 0.4				peakcurrentlocend = 1.5				offsetminus = 0.001				offsetplus = 0.001			else												//set parameters for AMPAR/CTZ (==2)				peakcurrentlocbegin = 0.04 				peakcurrentlocend = 0.1				offsetminus = 0.0005				offsetplus = 0.0002			endif()					endif()		Wavestats/Q/R=(peakcurrentlocbegin,peakcurrentlocend) $avgsweep				//determining peak current for baseline application.			peakcurrentloc=V_minloc							//location of initial current amplitude		Wavestats/Q/R=(peakcurrentloc-offsetminus, peakcurrentloc+offsetplus) $avgsweep			mincurrent=V_avg									//averages inward currents around min current loc		Wavestats/Q/R=(startss,endss) $avgsweep				//determines steady-state current			Peak_SS = V_avg								//Assigns steady-state current to wave				PDesens = 	100*(1-(Peak_SS/mincurrent	)	)					sscurrentampl = Peak_SS				chargeintegral = area($avgsweep,endleak,startss)		Display $avgsweep			SetScale/I x startss,endss,"", sscurrentampl		Duplicate/O sscurrentampl $sscurrent				append $sscurrent		ModifyGraph rgb($sscurrent)=(0,0,0)//**need to determine the specific fit (single or double exponential) to be used		if (Type == 2)													//this is for CTZ where no fit is needed			Textbox /F=0/A=LB/X=40/Y=30 	"current wave: " + firstsweep			AppendText "Leak current = " + num2str(leakcurrent) + " pA"			AppendText "SS current = " + num2str(Peak_SS) + " pA"		else			//**doing the proper fit			if (fittype == 1)											//set parameters for single exponential fit				CurveFit exp $avgsweep (peakcurrentloc,startss) /D					tau1 = 1000/W_coef[2]					fit = "fit_" + avgsweep				ModifyGraph rgb($fit)=(0,0,0)						else 					 									//fittype = 2; fit double exponential				CurveFit dblexp_XOffset  $avgsweep(peakcurrentloc+fitoffset, endss) /D 		//Fit for double exponential fit					tau1 = round((W_coef[2]*1000)*10)/10					tau2 = round((W_coef[4]*1000)*10)/10					Area1 = W_coef[1]					Area2 = W_coef[3]					FractionArea1 = round((Area1/(Area1+Area2))*100)/100					FractionArea2 = round((Area2/(Area1+Area2))*100)/100					fit = "fit_" + avgsweep				ModifyGraph rgb($fit)=(0,0,0)			endif()						//**need to define how to display results for ds or deact			if (DataType == 0)				Textbox /F=0/A=LB/X=40/Y=30 	"current wave: " + firstsweep					AppendText "Leak current = " + num2str(leakcurrent) + " pA"					AppendText "peak current = " + num2str(mincurrent) + " pA"					AppendText "SS current = " + num2str(Peak_SS) + " pA"					AppendText "% Desensitization = " + num2str(PDesens) + "%"					AppendText "Tau1 = " + num2str(tau1) + " ms" + ", FArea1 = " + num2str(FractionArea1) 					AppendText "Tau2 = " + num2str(tau2) + " ms" + ", FArea2 = " + num2str(FractionArea2) 			else				Textbox /F=0/A=LB/X=40/Y=30 	"current wave: " + firstsweep					AppendText "Leak current = " + num2str(leakcurrent) + " pA"					AppendText "peak current = " + num2str(mincurrent) + " pA"					AppendText "Tau1 = " + num2str(tau1) + " ms" + ", FArea1 = " + num2str(FractionArea1) 					AppendText "Tau2 = " + num2str(tau2) + " ms" + ", FArea2 = " + num2str(FractionArea2) 					AppendText "ChargeIntegral = " + num2str(chargeintegral) 				endif()				endif()									End Macro()//***********************************************************************//***Routine measures respone to multiple applications of glutamate.  Macro FastTrain(RawWavetoAnalyze,NumberofPulses,StartLeak,EndLeak,StartLateLeak,EndLateLeak,AverageAroundPeak)	String RawWavetoAnalyze		prompt RawWavetoAnalyze,"Current record to analyze?",popup,WaveList("*",";","");";_none_"	Variable NumberofPulses = 10		prompt NumberofPulses, "Number of brief applns?"	Variable StartLeak = 0.02		prompt StartLeak, "Start of leak current?"	Variable EndLeak = 0.95		prompt EndLeak, "End of leak current?"	Variable StartLateLeak = 4		prompt StartLateLeak, "Start of late leak current?"	Variable EndLateLeak = 5		prompt EndLateLeak, "End of late leak current?"	Variable AverageAroundPeak = 0.0001		prompt AverageAroundPeak, "Average around peak?"	Silent 1	Variable leakcurrent,leaklatecurrent	Variable leakcurrenttime = (StartLeak + EndLeak)/2	Variable leaklatecurrenttime = (StartLateLeak + EndLateLeak)/2					Variable wavetoanalyzelength										//variable for length of name	Variable numberofapplns											//used to define length of WavetoSmooth	Variable thresholdlevel = 0.2										//level of detection for FindLevels	Variable currentintegral	Variable counter = 0	Variable peaklocation	Variable pulseduration = 0.002		Variable tau1,tau2,area1,area2,fractionarea1,fractionarea2	Variable deactweightedtau		String wavetoanalyze	String wavebasename	String piezowave														//name for wave with piezo pulses	String seriesnumber													//name to distinguish different records within same file	String peaklocation_wave,peakcurrent_wave		Make/O/N=(NumberofPulses) peakcurrentlocation	Make/O/N=(NumberofPulses) peakcurrentvalue//Create new wave to protect raw wave	wavetoanalyze = RawWavetoAnalyze + "_pA"			Duplicate/O $RawWavetoAnalyze,tempwave							//This is done to protect original wave from changes in scaling.		tempwave = tempwave*10^12										//scale to pAmps				Wavestats/Q/R=(StartLeak,EndLeak) tempwave					//defines leakcurrent			leakcurrent=V_avg		Wavestats/Q/R=(StartLateLeak,EndLateLeak) tempwave					//defines leakcurrent after (late) the pulse			leaklatecurrent=V_avg			/////////Need to define linear basis of these two leaks/////////Then need to subtract out from total wave.				Duplicate/O tempwave,subtracttempwave							//Routine to subtract out liner basis of leak. 			subtracttempwave = 0					Make/O/N=2 linearwave											//Define linearwave & set equal to leak values			linearwave[0] = leakcurrent			linearwave[1] = leaklatecurrent					SetScale/I x leakcurrenttime,leaklatecurrenttime,"", linearwave			CurveFit line linearwave /D						subtracttempwave = W_coef[0]+W_coef[1]*x		tempwave = tempwave - subtracttempwave						//Removing linear leak from analysis wave			//		tempwave = tempwave - leakcurrent							//leak subtraction	//Identify time wave for smoothed wave - assumes that time wave and fluoro wave differ only by x & t	wavetoanalyzelength = strlen(RawWavetoAnalyze)		wavebasename = RawWavetoAnalyze[0,wavetoanalyzelength - 9]				piezowave = wavebasename + "_2_Adc-2"	//Define currentintegral. Done here to define if current is inward to outward.		currentintegral = round(area(tempwave,endleak,startlateleak)*10)/10//Findlevels finds the location of peaks for the piezo record.  These peaks will be used to peak current amplitudes.		FindLevels /D=peaklocationwave/EDGE=1/M=0.02 /N=(NumberofPulses)/Q $piezowave,thresholdlevel					counter = 0	do		peaklocation = peaklocationwave[counter]					//uses initial estimate from piezo wave		Wavestats/Q/R=(peaklocation,peaklocation+0.02) tempwave			if (currentintegral<0)							//Current is inward				peakcurrentlocation[counter] = V_minloc			else												//Current is outward				peakcurrentlocation[counter] = V_maxloc			endif		peaklocation = peakcurrentlocation[counter]				//changes estimate to peak current for actual current record					Wavestats/Q/R=(peaklocation-AverageAroundPeak,peaklocation+AverageAroundPeak) tempwave			peakcurrentvalue[counter] = V_avg				counter +=1		while(counter<NumberofPulses)	//Routine to give unique names to each Series	seriesnumber = RawWavetoAnalyze[8,wavetoanalyzelength - 13]	//defines series number		 peaklocation_wave = "peaklocation" + seriesnumber		 peakcurrent_wave = "peakcurrent" + seriesnumber		Duplicate/O peakcurrentlocation,$peaklocation_wave		Duplicate/O peakcurrentvalue,$peakcurrent_wave		Duplicate/O tempwave,$wavetoanalyze			currentintegral = round(area($wavetoanalyze,endleak,startlateleak)*10)/10		display/W=(50,50,500,400) $wavetoanalyze			ModifyGraph rgb($wavetoanalyze)=(30583,30583,30583)			ModifyGraph zero(left)=4			append $peakcurrent_wave vs $peaklocation_wave				ModifyGraph mode($peakcurrent_wave)=3,rgb($peakcurrent_wave)=(65535,0,0),marker($peakcurrent_wave)=19,msize($peakcurrent_wave)=2			Label left "I (pA)";DelayUpdate			Label bottom "time (seconds)"			Textbox /F=0/A=LB/X=40/Y=30 "Current integral = " + num2str(currentintegral) + " pC"//Routine to fit double exponential to deactivation cruve.	CurveFit/Q=1 dblexp_XOffset  $wavetoanalyze(peakcurrentlocation[counter],EndLateLeak) /D 		//Fit for double exponential fit				tau1 = round((W_coef[2]*1000)*10)/10				tau2 = round((W_coef[4]*1000)*10)/10				area1 = W_coef[1]				area2 = W_coef[3]				fractionarea1 = round((area1/(area1+area2))*100)/100				fractionarea2 = round((area2/(area1+area2))*100)/100										deactweightedtau = tau1*fractionarea1 + tau2*fractionarea2								AppendText "Weighted tau = " + num2str(deactweightedtau) + " msec"				AppendText "Leak current = " + num2str(leakcurrent) + " pA"										display/W=(50,400,500,600) subtracttempwave					//Displaying leak current.  Not certain necessary.			SetAxis left -200,200	Edit/W=(500,50,800,400) $peaklocation_wave,$peakcurrent_waveEnd macro		//*********************************************************************************************//***Analysis of a train of pulses to test effects over time.Macro SlowTrain(Type,GroupNo,SeriesNo,FirstSweepNo,LastSweepNo,StartSS,EndSS,TimeBase)	Variable Type = Gtype		prompt type, "AMPA (0), NMDA (1), AMPA CTZ (2)"	Variable GroupNo = GGroupNo		prompt GroupNo, "Group number"	Variable SeriesNo = GSeriesNo		prompt SeriesNo, "Series number"	Variable FirstSweepNo = GFirstSweepNo		prompt FirstSweepNo, "First sweep number"	Variable LastSweepNo = GLastsweepno		prompt LastSweepNo, "Last sweep number"	Variable StartSS = Gstartss		prompt StartSS, "Start of SS (0.15,AMPA; 2.8, NMDA)"	Variable EndSS = Gendss		prompt EndSS, "End of SS (0.2, AMPA; 3.0, NMDA)"	Variable TimeBase = 15		prompt TimeBase, "Total sweep duration (sec)"	Silent 1	Gtype = Type	GGroupNo = GroupNo	GSeriesNo = SeriesNo	GFirstSweepNo = FirstSweepNo	GLastsweepno = LastSweepNo	Gstartss = StartSS	Gendss = EndSS	Variable startleak = 0.05,endleak	Variable thresholdlevel = 0.2									//level of detection for FindLevels.  Used initially for Piezo wave and then for baseline noise.	Variable peakcurrentlocation,peakcurrent,sscurrent	Variable sweepcounter,tablecounter,totalnosweeps	Variable piezostart,leakcurrent		Variable peakcurrentlocbegin,peakcurrentlocend			//parameters for defining average of mean	Variable offsetminus, offsetplus	Variable fitoffset = 0.05	Variable weightedtau,percentds								//Analysis variables	Variable tau1, tau2, Area1, Area2, FractionArea1, FractionArea2	Variable deactweightedtau	Variable Approval		String rawwave,analysiswave									//Wave for time dependence	String peakcurrentdisplay,sscurrentdisplay	String timebasewave,leakcurrentwave,peakcurrentwave,sscurrentwave,weightedtauwave,percentdswave,deactweightedtauwave			//Waves for each series.  Prevents overwrite.		timebasewave = "timebasewave" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		leakcurrentwave = "leakcurrentwave" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		peakcurrentwave = "peakcurrentwave" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		sscurrentwave = "sscurrentwave" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		percentdswave = "percentds" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		weightedtauwave = "weightedtau" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)		deactweightedtauwave = "deactweightedtau" +  num2str(SeriesNo) + "_" + num2str(FirstSweepNo)	String firstsweepwave,piezowave	String graphname,fitdisplay	String WaveNameBase = GWaveNameBase	String EndNameBase = GEndNameBase	String PiezoNameBase = GPiezoNameBase		firstsweepwave =  wavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + endnamebase		piezowave =  wavenamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(FirstSweepNo) + piezonamebase	Make/O/N=(2) displaywave//Findlevels finds the startpoint of the piezo record.  This startpoint will be used as reference for start of ALL glutamate applications.	FindLevel/EDGE=1 /Q $piezowave, thresholdlevel		piezostart = V_LevelX			endleak = piezostart - 0.05								//uses piezostart time to determine leak current//defining parameters for determining amplitudes for AMPAR versus NMDARs		if (Type == 0)													//set parameters for AMPAR (==0)			peakcurrentlocbegin = 0.04 			peakcurrentlocend = 0.1			offsetminus = 0.0002			offsetplus = 0.0005					else																		if (Type == 1) 												//set parameters for NMDAR (==1)				peakcurrentlocbegin = 0.4				peakcurrentlocend = 0.6				offsetminus = 0.002				offsetplus = 0.016			else															//set parameters for AMPAR/CTZ (==2)				peakcurrentlocbegin = 0.04 				peakcurrentlocend = 0.1				offsetminus = 0.0005				offsetplus = 0.0002			endif()					endif()//**Routine to extract peak values over time for individual traces**	totalnosweeps = (LastSweepNo + 1) - FirstSweepNo		Make/O/N=(totalnosweeps) $timebasewave,$leakcurrentwave,$peakcurrentwave,$sscurrentwave,$weightedtauwave,$percentdswave,$deactweightedtauwave		$timebasewave = 0;$leakcurrentwave = 0;$peakcurrentwave = 0;$sscurrentwave = 0;$weightedtauwave = 0;$percentdswave = 0;$deactweightedtauwave = 0	sweepcounter = firstsweepno	tablecounter = 0	do																		//Do...while for sweepnumber.			if (sweepcounter < 10)				rawwave = WaveNamebase + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_00" + num2str(sweepcounter) + EndNamebase			else				if (sweepcounter < 100)					rawwave = WaveNamebase + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_0" + num2str(sweepcounter) + EndNamebase				else					rawwave = WaveNamebase + "_" + num2str(groupno) + "_" + num2str(seriesno) + "_" + num2str(sweepcounter) + EndNamebase				endif()			endif()						analysiswave = WaveNamebase + num2str(seriesno) + "_" + num2str(sweepcounter)				Duplicate/O $rawwave,$analysiswave					peakcurrentdisplay = "peakcurrent_" + num2str(sweepcounter) 		//setting paramters for display of average values		sscurrentdisplay = "sscurrent_" + num2str(sweepcounter)			Duplicate/O displaywave $peakcurrentdisplay			Duplicate/O displaywave $sscurrentdisplay				$analysiswave=$analysiswave*10^12							//converts current to pA		Wavestats/Q/R=(startleak,endleak) $analysiswave			//defines leakcurrent			leakcurrent = V_avg			$analysiswave=$analysiswave-leakcurrent			//analysis of selected sweep		do			Wavestats/Q/R=(peakcurrentlocbegin,peakcurrentlocend) $analysiswave		//determining peak current for baseline application.				peakcurrentlocation=V_minloc													//location of initial current amplitude			Wavestats/Q/R=(peakcurrentlocation-offsetminus, peakcurrentlocation+offsetplus) $analysiswave				peakcurrent=V_avg																//averages inward currents around min current loc			Wavestats/Q/R=(StartSS,EndSS) $analysiswave									//determines steady-state current				sscurrent = V_avg																//Assigns steady-state current to wave					percentds = 	100*(1-(sscurrent/peakcurrent	)	)	//define graph name so that 1st and last are displayed			if (sweepcounter == firstsweepno)								graphname = "graph0"							else				if (sweepcounter == lastsweepno)					graphname = "graph1"								else					graphname = "graph2"				endif						endif				Display/N=$graphname/W=(100,100,800,500) $analysiswave						Label left "I (pA)";DelayUpdate				Label bottom "time (s)"					SetScale/I x StartSS,EndSS,"", $sscurrentdisplay					$sscurrentdisplay = sscurrent				SetScale/I x endleak,peakcurrentlocation+offsetplus,"", $peakcurrentdisplay					$peakcurrentdisplay = peakcurrent					append $sscurrentdisplay				ModifyGraph rgb($sscurrentdisplay)=(0,0,0)			append $peakcurrentdisplay				ModifyGraph rgb($peakcurrentdisplay)=(0,0,0)			//need to distinguish current type (AMPA vs NMDA) to determine fits and results to display			if (Type == 0)											//set parameters for AMPAR (==0)				CurveFit exp $analysiswave (peakcurrentlocation,EndSS) /D					tau1 = 1000/W_coef[2]					fitdisplay = "fit_" + analysiswave				ModifyGraph rgb($fitdisplay)=(0,0,0)					else																	if (type == 1) 									//set parameters for NMDAR (==1)					CurveFit/Q=1 dblexp_XOffset  $analysiswave(peakcurrentlocation+fitoffset, endss) /D 		//Fit for single exponential fit//					CurveFit/Q=1 dblexp_XOffset  $analysiswave(endss+0.015, 3.9) /D 		//Fit for double exponential fit						tau1 = round((W_coef[2]*1000)*10)/10						tau2 = round((W_coef[4]*1000)*10)/10						area1 = W_coef[1]						area2 = W_coef[3]						fractionarea1 = round((area1/(area1+area2))*100)/100						fractionarea2 = round((area2/(area1+area2))*100)/100												weightedtau = tau1*fractionarea1 + tau2*fractionarea2						//					fitdisplay = "fit_" + analysiswave								ModifyGraph rgb($fitdisplay)=(0,0,0)						Textbox/F=0/A=MT analysiswave 						Appendtext "peak current = " + num2str(peakcurrent) + " pA"						AppendText "SS current = " + num2str(sscurrent) + " pA"						AppendText "% Desensitiation = " + num2str(percentds) + "%"						AppendText "weighted tau = " + num2str(weightedtau) + " ms"						AppendText "Tau1 = " + num2str(tau1) + " ms"						AppendText "FArea1 = " + num2str(FractionArea1) 						AppendText "Tau2 = " + num2str(tau2) + " ms"						AppendText "FArea2 = " + num2str(FractionArea2) 						else												//set parameters for AMPAR/CTZ (==2)					Textbox /F=0/A=MT 	"current wave: " + firstsweep					AppendText "SS current = " + num2str(sscurrent) + " pA"				endif()			endif()//**Subroutine to determine quality of fit			ReAnalyzeorNot()											//verify that outcome is OK or not...				Approval = GReAnalorNot							//"Good enough (y=1); Reanalyze sweep (2); DO NOT ANALYZE (3):"					if (Approval == 1)																						$timebasewave[tablecounter] = tablecounter * timebase			//Adds values to appropriate waves						$leakcurrentwave[tablecounter] = leakcurrent						$peakcurrentwave[tablecounter] = peakcurrent						$sscurrentwave[tablecounter] = sscurrent						$weightedtauwave[tablecounter] = weightedtau						$percentdswave[tablecounter] = percentds						$deactweightedtauwave[tablecounter] = deactweightedtau											else						if (Approval == 2)																		//							RemoveFromGraph startptdisplay							NewParameters()							//select new range to analyze								fitoffset = Gfitoffset								StartSS = GStartSS								EndSS = GEndSS														else											//means Approval is '3'.  Do not analyze wave. No value added to delaytofirstvalues.																						$timebasewave[tablecounter] = tablecounter * timebase			//Adds values to appropriate waves							$leakcurrentwave[tablecounter] = NaN							$peakcurrentwave[tablecounter] = NaN							$sscurrentwave[tablecounter] = NaN							$weightedtauwave[tablecounter] = NaN							$percentdswave[tablecounter] = NaN							$deactweightedtauwave[tablecounter] = NaN														Approval = 1											endif					  					endif							while(Approval !=1)			KillWindow/Z graph2								sweepcounter+=1						tablecounter+=1			while (sweepcounter < lastsweepno+1)//Plotting individual peak values			Display/W=(10,10,450,225) $peakcurrentwave vs $timebasewave				ModifyGraph mode=3,marker=19,rgb=(0,0,0)				SetAxis left *,0				Label bottom "Time (sec)"				Label left "I (pA)"								Wavestats/Q $peakcurrentwave					 			//wave stats of peak values over time					 peakcurrent= round(V_avg*10)/10				Textbox/A=LB /F=0					AppendText "Ipeak avg (circles) = " + num2str(peakcurrent)			//Plotting percentds and weighted tau			Display/W=(10,275,450,500) $percentdswave vs $timebasewave				ModifyGraph mode=3,marker=0				SetAxis left 0,*				Label bottom "Time (sec)"				Label left "% Ds"			Append/R $weightedtauwave vs $timebasewave				ModifyGraph mode=3,marker($weightedtauwave)=5,rgb=(0,0,0)				SetAxis right 0,*				Label right "Weighted tau (ms)"												Wavestats/Q $weightedtauwave					 			//wave stats of peak values over time					 weightedtau = round(V_avg*10)/10				Textbox/A=RB /F=0					AppendText "Avg weighted tau (squares) = " + num2str(weightedtau)												Wavestats/Q $percentdswave					 					//wave stats of peak values over time					 percentds = round(V_avg*100)/100				Textbox/A=LB /F=0					AppendText "Avg percentds (+) = " + num2str(percentds)//Plotting deactivation weighted tau			Display/W=(10,275,450,500) $deactweightedtauwave vs $timebasewave				ModifyGraph mode=3,marker=0				SetAxis left 0,*				Label bottom "Time (sec)"				Label left "Deact weighted tau"		Edit/W=(450,10,800,400) $timebasewave,$leakcurrentwave,$peakcurrentwave,$sscurrentwave,$percentdswave,$weightedtauwave,$deactweightedtauwave	End Macro()//***********************************************************************//***Macro quantifies recovery from desensitization. //needs updating...Macro Recovery (subtype,GroupNo, SeriesNo, sweepno, noshortappln,nolongappln,includefirst,pulselength)	Variable subtype = 1	prompt subtype, "AMPA = 0, NMDA = 1"	Variable GroupNo = GGroupNo	prompt GroupNo, "Group number"	Variable SeriesNo = GSeriesNo	prompt SeriesNo, "Exp. number"	Variable sweepno  =1	prompt sweepno, "sweep number"	Variable noshortappln = Gnoshortappln	prompt noshortappln,"Number of short recovery application"	Variable nolongappln = Gnolongappln	prompt nolongappln,"Number of long recovery application"	Variable includefirst = Gincludefirst	prompt includefirst,"Include first pt in fit? (0 = y, 1 = n) "	Variable pulselength = Gpulselength	prompt pulselength,"Length of base appln (ms)?  "		GGroupNo = GroupNo	GSeriesNo = SeriesNo	sweepno = sweepno	Gnoshortappln = noshortappln	Gnolongappln = nolongappln	Gincludefirst = includefirst	Gpulselength = pulselength	subtype = subtype	Silent 1		Variable totalnoapplns=noshortappln+nolongappln	Variable totalsweepno=1		Variable Approval	Make/O/N=(totalnoapplns+1) TestAppln_Loc						//Time values of recovery	Make/O/N=(totalnoapplns+1) TestAppln_Ampl						//Recovery current values	Make/O/N=(totalnoapplns+1) BaseAppln_Loc		Make/O/N=(totalnoapplns+1) BaseAppln_Ampl						//Peak currents for base appln 	Make/O/N=(totalnoapplns+1) BaseAppln_SS						//Steady-state currents for base appln 	Make/O/N=(totalnoapplns+1) PRecovery	Make/O/N=(totalnoapplns+1) PRecovery_Norm		TestAppln_Loc[totalsweepno-1] = 0		TestAppln_Ampl[totalsweepno-1] = 0		BaseAppln_Loc[totalsweepno-1] = 0		BaseAppln_Ampl[totalsweepno-1] = 0		BaseAppln_SS[totalsweepno-1] = 0		PRecovery[totalsweepno-1] = 0			PRecovery_Norm[totalsweepno-1] = 0			String iniwavename, subtwave	pulselength=pulselength	/1000								//Convert pulse length to seconds		String WaveNameBase="pulse"	String EndNameBase= "_1_I-mon"	if (subtype == 1)		Variable startleak = 0.1									//parameters to define baseline for leak substraction		Variable endleak = 0.3		Variable startss = (0.5+pulselength)-0.2							//parameters to define steady-state current during base appln		Variable endss = (0.5+pulselength)-0.1	else 		Variable startleak = 0.02									//parameters to define baseline for leak substraction		Variable endleak = 0.03		Variable startss = 0.12							//parameters to define steady-state current during base appln		Variable endss = 0.13	endif		Variable traceno,globaltraceno,notempappln,tempcounter	Variable Initamp	Variable temp_num,temp_den	Variable tau,tau_norm	notempappln=noshortappln	tempcounter=1		do																	//loop distinguishes between different PGF records			do																//loop analyzes individual waves within an experiment						if (sweepno < 10)										//Needed to allow user to analyze single later traces				iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_00" + num2str(sweepno) + EndNamebase			else				if (sweepno < 100)					iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_0" + num2str(sweepno) + EndNamebase				else					iniwavename =  WaveNamebase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepno) + EndNamebase				endif()			endif()//			iniwavename = WaveNameBase + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepno) + EndNameBase			subtwave = "rec_subwave" + num2str(totalsweepno)			Duplicate/O $iniwavename leakycurrentwave 				//*leak substract wave & convert to pAs				leakycurrentwave=leakycurrentwave*10^12			//converts current to pA				Wavestats/Q/R=(startleak,endleak) leakycurrentwave	//defines leakcurrent					leakcurrent=V_avg				leakycurrentwave=leakycurrentwave-leakcurrent		//leak subtraction						if (subtype == 1)		//NMDARs					Duplicate/O leakycurrentwave $subtwave						//working wave for analysis				Wavestats/Q/R=(0.4,0.6) $subtwave						//determining peak current for baseline application.					peakcurrentloc=V_minloc								//location of initial current amplitude					Wavestats/Q/R=(peakcurrentloc-0.001,peakcurrentloc+0.001) $subtwave		//makes average around peakcurrent						BaseAppln_Ampl[totalsweepno] = V_avg				//Assigns peak current to wave						BaseAppln_Loc[totalsweepno] = peakcurrentloc					Wavestats/Q/R=(startss,endss) $subtwave					//determines steady-state current						BaseAppln_SS[totalsweepno] = V_avg					//Assigns steady-state current to wave															Wavestats/Q/R=(0.5+Pulselength+0.1) $subtwave			//determining PEAK current for TEST appln. Need to avoid base appln.						mincurrent=V_min									//assumes recovery was done at negative potentials						peakcurrentloc=V_minloc					Wavestats/Q/R=(peakcurrentloc-0.001,peakcurrentloc+0.001) $subtwave		//makes average around peakcurrent						TestAppln_Ampl[totalsweepno] = V_avg			//Assigns peak current to wave						TestAppln_Loc[totalsweepno] = peakcurrentloc			else						//AMPARS				Duplicate/O leakycurrentwave $subtwave					//working wave for analysis				Wavestats/Q/R=(0,0.075) $subtwave						//determining peak current for baseline application.					mincurrent=V_min										//assumes recovery was done at negative potentials					peakcurrentloc=V_minloc								//location of initial current amplitude						Wavestats/Q/R=(peakcurrentloc-0.0001,peakcurrentloc+0.0001) $subtwave		//makes average around peakcurrent						BaseAppln_Ampl[totalsweepno-1] = V_avg				//Assigns peak current to wave						BaseAppln_Loc[totalsweepno-1] = peakcurrentloc					Wavestats/Q/R=(peakcurrentloc+startss,peakcurrentloc+endss) $subtwave			//determines steady-state current						BaseAppln_SS[totalsweepno-1] = V_avg				//Assigns steady-state current to wave															Wavestats/Q/R=(0.15) $subtwave						//determining peak current for test appln. Need to avoid base appln.					mincurrent=V_min									//assumes recovery was done at negative potentials					peakcurrentloc=V_minloc					Wavestats/Q/R=(peakcurrentloc-0.0001,peakcurrentloc+0.0001) $subtwave		//makes average around peakcurrent						TestAppln_Ampl[totalsweepno-1] = V_avg		//Assigns peak current to wave						TestAppln_Loc[totalsweepno-1] = peakcurrentloc									endif								TestAppln_Ampl[0] = BaseAppln_SS[1]					PRecovery[totalsweepno]=100*TestAppln_Ampl[totalsweepno]/BaseAppln_Ampl[totalsweepno]							temp_num = TestAppln_Ampl[totalsweepno] - BaseAppln_SS[totalsweepno]					temp_den = BaseAppln_Ampl[totalsweepno] - BaseAppln_SS[totalsweepno]					PRecovery_Norm[totalsweepno]=100*temp_num/temp_den					PRecovery_Norm[0]=0			if (totalsweepno == 1)					Display $subtwave					Textbox/A=RB/F=0/X=0/Y=5 "wavename =  "+ WaveNameBase  + num2str(GroupNo) + "_" + num2str(SeriesNo) + "_" + num2str(sweepno)				else					Append $subtwave				endif						sweepno += 1			totalsweepno += 1						while (totalsweepno<(notempappln+1))			sweepno = 1		sweepno = sweepno + 1			notempappln=totalnoapplns				tempcounter +=1		while (tempcounter<(3))								Variable zerotime=BaseAppln_Loc[1] + Pulselength			//Zeroing test application time frame	//	TestAppln_Loc[1, totalnoapplns-1]=(TestAppln_Loc-zerotime)*1000			//use for fast recovery (ie A2)	//	TestAppln_Loc[0]=(TestAppln_Loc-zerotime)*1000										TestAppln_Loc=(TestAppln_Loc-zerotime)								// use for slow recovery (ie A1)			TestAppln_Loc[0]=0			//	Display PRecovery vs TestAppln_Loc	Display/W=(500,10,1100,300) PRecovery_norm vs TestAppln_Loc		ModifyGraph mode=3,marker=8,rgb=(0,0,0)		ModifyGraph marker(PRecovery_Norm)=19		SetAxis left 0,120 		SetAxis /A/N=1 bottom	Label left "%Recovery";DelayUpdate	Label bottom "time (s)"Silent 0	//routine to select range for fitting*****				do			InputCurveFitting()							includefirst = Gstartfit				totalnoapplns = Gendfit			CurveFit/Q/L=1000 exp PRecovery_norm(includefirst,totalnoapplns)/x=TestAppln_Loc /D				tau_norm = 1/W_coef[2]								Agreement()												//Verify that rev. potential fit OK...			Approval = YesOrNo		while(Approval !=1)		//	Make/D/N=4/O W_coef															//fit with HHfit//	W_coef[0] = {100,100,1,1}//	FuncFit HHfit W_coef  PRecovery /X=TestAppln_Loc /D 	Textbox/F=0/A=LB/X=40/Y=30 "tau_norm = "+num2str(tau_norm)+" s"//	AppendText "tau_HHfit = " +num2str(W_coef[1]) + "ms"//	AppendText "m_HHFit = " + num2str(W_coef[2])	if (subtype == 1)	Display/W=(500,300,1100,600) TestAppln_Ampl vs TestAppln_Loc		ModifyGraph mode = 3, marker=8, rgb=(0,0,0)		ModifyGraph marker (TestAppln_Ampl) = 30		SetAxis/A/N=1 left		SetAxis /A/N=1 bottomelse	Display/W=(500,300,1100,600) TestAppln_Ampl vs TestAppln_Loc		ModifyGraph mode = 3, marker=8, rgb=(0,0,0)		ModifyGraph marker (TestAppln_Ampl) = 30		SetAxis/A/N=1 left		SetAxis/A/N=1 bottom endif			Label left "Peak Current Amps (pA)"; DelayUpdate	Label bottom "time (s)"Silent 0	CurveFit/Q/L=1000 exp TestAppln_Ampl(includefirst, totalnoapplns) /x=TestAppln_Loc /D		tau = 1/W_coef[2]	Textbox /F=0/A=LB/X=40/Y=30 "Tau = " + num2str(tau) + "ms"		Edit/W=(10,300,450,650) BaseAppln_Loc,BaseAppln_Ampl,TestAppln_Loc,TestAppln_Ampl,PRecovery_Norm		ModifyTable width(Point)=0, sigDigits(PRecovery_Norm)=4		ModifyTable width(TestAppln_Loc)=74, width(PRecovery_Norm)=90EndMacro////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Macro displays open tip responses. //needs updating...Macro OpenTip(shortGroupNo,shortSeriesNo,longGroupNo,longSeriesNo)	Variable shortGroupNo=1	prompt shortGroupNo, "Group no. of 1 ms appln"	Variable shortSeriesNo= 1	prompt shortSeriesNo, "Exp. no. of 1 ms appln"	Variable longGroupNo=1	prompt longGroupNo, "Group no of 100 ms appln"	Variable longSeriesNo= 1	prompt longSeriesNo, "Exp. no. of 100 ms appln"	Silent 1		 	Variable GroupNo=1	Variable sweepno=1	Variable SeriesNo=1	Variable counter	Variable baseline,baserange	Variable temp=1	Variable mat=2	Variable bottomaxismin, bottomaxismax	Variable PeakCurrent_10,PeakCurrent_90	Variable TIme_10,Time_90,risetime		String wavetype,peakpoint,peakcurrentlocation	String analysiswave,testwave		String WaveNameBase="pulse"	String EndNameBase= "_1_I-mon"		Make/O/N=2 pcurrent	Make/O/N=2 pcurrentlocation	Make/O/N=2 temp2ptwave	Make/O/N=1 temp1ptwave	Make/O/N=2 pcurrent_10wave	Make/O/N=2 pcurrent_90wave		Counter=0       	Do																	//Subroutine for analysis of Deactivation & desensitization recordd		If (counter==0)												//Counter=0, Short appln			GroupNo=shortGroupNo			SeriesNo=shortSeriesNo			wavetype="short"			sweepno=1			bottomaxismin=0.020				bottomaxismax=0.030		else																//Counter=1, Long appln			GroupNo=longGroupNo			SeriesNo=longSeriesNo			wavetype="long"			sweepno = 1			bottomaxismin=0			bottomaxismax=0.15		endif		AnalysisWave =  WaveNameBase + "_" + num2str(GroupNo) + "_" + num2str(SeriesNo) + EndNameBase		PeakPoint="PeakPoint"+num2str(GroupNo)+"_"+num2str(SeriesNo)		PeakCurrentLocation="PeakCurrentLocation"+num2str(GroupNo)+"_"+num2str(SeriesNo)		Duplicate/O $AnalysisWave, tempwave			tempwave=tempwave*10^12										//Scale to pAmps			Wavestats/Q tempwave			pcurrent[counter]=V_min			pcurrentlocation[counter]=V_minloc												baserange=pcurrentlocation[counter]-0.008						//Define Baseline			Wavestats/Q/R=[0.002,baserange] tempwave					//Determine Baseline			baseline=V_avg			tempwave=tempwave-baseline										//Subtract Baseline		pcurrent[counter]=pcurrent[counter]-baseline						//Correct Peak current for leak			testwave= wavetype + num2str(GroupNo)+"_"+num2str(SeriesNo)		//Graphing Current response & values		Duplicate/O tempwave $testwave			Display $testwave			ModifyGraph rgb($testwave)=(0,0,0)			Label left "Current (pA)"			Label bottom "time (ms)"			SetAxis bottom bottomaxismin,bottomaxismax 			ModifyGraph nticks(bottom)=4			ModifyGraph zero(bottom)=3				Duplicate/O temp1ptwave $PeakPoint				$PeakPoint[0]=pcurrent[counter]/2		Duplicate/O temp1ptwave $PeakCurrentLocation				$PeakCurrentLocation[0]=pcurrentlocation[counter]				Append $PeakPoint vs $PeakCurrentLocation				ModifyGraph mode($PeakPoint)=3,marker($PeakPoint)=22,rgb($PeakPoint)=(0,0,0)								Textbox/A=RC/X=0/Y=0/F=0 AnalysisWave			Appendtext "PCurrent="+num2str(round(pcurrent[counter]))+ " pA"					If (counter==0)												//Rountine to define 10 & 90% Rise times			PeakCurrent_10=pcurrent[counter]*0.10			PeakCurrent_90=pcurrent[counter]*0.90						pcurrent_10wave=PeakCurrent_10			SetScale/I x bottomaxismin,bottomaxismax,"" pcurrent_10wave			Append pcurrent_10wave			ModifyGraph lstyle(pcurrent_10wave)=3				Findlevel/Q/R=(bottomaxismin,bottomaxismax) $testwave PeakCurrent_10				Time_10=V_levelx							pcurrent_90wave=PeakCurrent_90			SetScale/I x bottomaxismin,bottomaxismax,"", pcurrent_90wave			Append pcurrent_90wave			ModifyGraph lstyle(pcurrent_90wave)=3				Findlevel/Q/R=(bottomaxismin,bottomaxismax) $testwave PeakCurrent_90				Time_90=V_levelx							RiseTime=(Time_90-Time_10)*1000000					//Time in microseconds			Appendtext "10-90% RiseTime ="+num2str(round(RiseTime)) + " usecs"									endif		counter +=1		while(counter<2)		           	End Macro()